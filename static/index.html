<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video to Sprite Sheet</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Outfit:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --accent-hover: #79b8ff;
      --success: #3fb950;
      --error: #f85149;
      --radius: 12px;
      --radius-sm: 8px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Outfit', -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .container {
      width: 100%;
      max-width: 720px;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.95rem;
      margin-bottom: 2rem;
    }

    .step-badge {
      display: inline-block;
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      background: rgba(88, 166, 255, 0.15);
      padding: 0.25rem 0.6rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .upload-zone {
      border: 2px dashed var(--border);
      border-radius: var(--radius);
      padding: 3rem 2rem;
      text-align: center;
      background: var(--surface);
      transition: border-color 0.2s, background 0.2s;
      cursor: pointer;
      position: relative;
      margin-bottom: 1.5rem;
    }

    .upload-zone:hover,
    .upload-zone.drag-over {
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.06);
    }

    .upload-zone input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    .upload-zone .icon {
      font-size: 2.5rem;
      margin-bottom: 0.75rem;
      opacity: 0.7;
    }

    .upload-zone .hint {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-family: 'JetBrains Mono', monospace;
    }

    .upload-zone .formats {
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }

    .preview-section {
      display: none;
      background: var(--surface);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .preview-section.visible {
      display: block;
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border);
      gap: 1rem;
      flex-wrap: wrap;
    }

    .preview-header .filename {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text);
      word-break: break-all;
    }

    .preview-header .change-btn {
      font-size: 0.85rem;
      color: var(--accent);
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.35rem 0.75rem;
      border-radius: var(--radius-sm);
      font-family: inherit;
      transition: background 0.2s, color 0.2s;
    }

    .preview-header .change-btn:hover {
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent-hover);
    }

    .video-wrapper {
      background: #000;
      aspect-ratio: 16 / 9;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 240px;
    }

    .video-wrapper video {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
    }

    .status {
      padding: 1rem 1.25rem;
      font-size: 0.9rem;
      display: none;
    }

    .status.visible {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status.loading {
      color: var(--text-muted);
    }

    .status.error {
      color: var(--error);
    }

    .status.success {
      color: var(--success);
    }

    .status .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-zone {
      display: none;
      padding: 2rem;
      text-align: center;
    }

    .loading-zone.visible {
      display: block;
    }

    /* Step 2 ‚Äî Frame range */
    .step2-section {
      display: none;
      margin-top: 2rem;
    }

    .step2-section.visible {
      display: block;
    }

    .frame-range-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-top: 1rem;
    }

    @media (max-width: 600px) {
      .frame-range-grid {
        grid-template-columns: 1fr;
      }
    }

    .frame-preview-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .frame-preview-card .label {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-muted);
    }

    .frame-preview-card .preview-box {
      aspect-ratio: 16 / 9;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 120px;
    }

    .frame-preview-card .preview-box img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      display: block;
    }

    .frame-preview-card .preview-box .placeholder {
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .overlay-card {
      grid-column: 1 / -1;
    }

    .overlay-box {
      position: relative;
    }

    .overlay-box img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .overlay-box .overlay-bg {
      z-index: 0;
    }

    .overlay-box .overlay-fg {
      z-index: 1;
      opacity: 0.5;
    }

    .frame-preview-card .slider-row {
      padding: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .frame-preview-card input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--border);
      border-radius: 3px;
      outline: none;
    }

    .frame-preview-card input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s;
    }

    .frame-preview-card input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .frame-preview-card input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .frame-preview-card .frame-num {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text);
      min-width: 4ch;
    }

    .range-summary {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(88, 166, 255, 0.08);
      border-radius: var(--radius-sm);
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .range-summary strong {
      color: var(--accent);
    }

    .sampling-section {
      margin-top: 1.5rem;
      padding: 1rem 1.25rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .sampling-section .label {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
      display: block;
    }

    .sampling-options {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }

    .sampling-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
    }

    .sampling-option input[type="radio"] {
      accent-color: var(--accent);
    }

    .sampling-n-input {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sampling-n-input input {
      width: 4rem;
      padding: 0.35rem 0.5rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
    }

    .looped-preview-card {
      margin-top: 1.5rem;
    }

    .looped-preview-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      border-top: 1px solid var(--border);
    }

    .looped-preview-controls label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .looped-preview-controls input[type="range"] {
      width: 120px;
    }

    .looped-preview-controls .fps-value {
      font-family: 'JetBrains Mono', monospace;
      min-width: 3ch;
    }

    .looped-preview-info {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    /* Step 3 ‚Äî Chroma key */
    .step3-section {
      display: none;
      margin-top: 2rem;
    }

    .step3-section.visible {
      display: block;
    }

    .chroma-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-top: 1rem;
    }

    @media (max-width: 700px) {
      .chroma-grid { grid-template-columns: 1fr; }
    }

    .chroma-viewport {
      position: relative;
      background: #000;
      aspect-ratio: 16 / 9;
      min-height: 140px;
      overflow: hidden;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    }

    .chroma-viewport.dragging {
      cursor: grabbing;
    }

    .chroma-picker-box.dragging {
      cursor: grabbing;
    }

    .chroma-viewport-inner {
      position: absolute;
      transform-origin: 0 0;
      will-change: transform;
    }

    .chroma-viewport-inner canvas {
      display: block;
      vertical-align: top;
    }

    .chroma-viewport.chroma-preview-box {
      background: repeating-conic-gradient(#333 0% 25%, #222 0% 50%) 50% / 16px 16px;
    }

    .chroma-viewport.chroma-preview-box.bg-black {
      background: #000;
    }

    .chroma-viewport.chroma-preview-box.bg-white {
      background: #fff;
    }

    .chroma-viewport.chroma-preview-box.bg-gray {
      background: #666;
    }

    .chroma-preview-bg-options {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .chroma-preview-bg-options label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: var(--text-muted);
      cursor: pointer;
    }

    .chroma-preview-bg-options input[type="radio"] {
      accent-color: var(--accent);
    }

    .chroma-zoom-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .chroma-zoom-controls button {
      padding: 0.25rem 0.6rem;
      font-size: 0.85rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      cursor: pointer;
    }

    .chroma-zoom-controls button:hover {
      background: rgba(88, 166, 255, 0.15);
      border-color: var(--accent);
    }

    .chroma-controls {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .chroma-controls .row {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }

    .chroma-controls .row:last-child { margin-bottom: 0; }

    .color-swatch {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      border: 2px solid var(--border);
      flex-shrink: 0;
    }

    .color-swatch.empty {
      background: var(--border);
    }

    /* Step 4 ‚Äî Processed frames */
    .step4-section {
      display: none;
      margin-top: 2rem;
    }

    .step4-section.visible {
      display: block;
    }

    .processed-frames-nav {
      display: flex;
      align-items: center;
      justify-content: center;
      gap: 1rem;
      padding: 0.75rem 0;
      border-bottom: 1px solid var(--border);
    }

    .processed-frames-nav button {
      padding: 0.35rem 0.9rem;
      font-size: 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      cursor: pointer;
    }

    .processed-frames-nav button:hover {
      background: rgba(88, 166, 255, 0.15);
      border-color: var(--accent);
    }

    /* Step 5 ‚Äî Looping (optional) */
    .step5-section {
      display: none;
      margin-top: 2rem;
    }

    .step5-section.visible {
      display: block;
    }

    .step5-content {
      display: none;
      margin-top: 1rem;
    }

    .step5-content.visible {
      display: block;
    }

    .step5-overlay-box {
      position: relative;
      aspect-ratio: 16 / 9;
      min-height: 120px;
      background: repeating-conic-gradient(#333 0% 25%, #222 0% 50%) 50% / 16px 16px;
    }

    .step5-overlay-box img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .step5-overlay-box .overlay-bg { z-index: 0; }
    .step5-overlay-box #step5OverlayMid { z-index: 1; opacity: 0.5; }
    .step5-overlay-box .overlay-fg { z-index: 2; opacity: 0.5; }

    /* Step 6 ‚Äî Export Sprite Sheet */
    .step6-section {
      display: none;
      margin-top: 2rem;
    }
    .step6-section.visible {
      display: block;
    }
  </style>
</head>
<body>
  <div class="container">
    <span class="step-badge">Step 1 ‚Äî Upload</span>
    <h1>Video to Sprite Sheet</h1>
    <p class="subtitle">Upload a video file to get started. Supports MP4, AVI, MOV, WebM.</p>

    <div class="upload-zone" id="uploadZone" role="button" tabindex="0">
      <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/x-msvideo,video/webm,.mp4,.avi,.mov,.webm">
      <div class="icon">üé¨</div>
      <div class="hint">Drop a video file here or click to browse</div>
      <div class="formats">MP4, AVI, MOV, WebM</div>
    </div>

    <div class="loading-zone" id="loadingZone">
      <div class="status loading visible" id="statusLoading">
        <span class="spinner"></span>
        <span>Uploading‚Ä¶</span>
      </div>
    </div>

    <div class="preview-section" id="previewSection">
      <div class="preview-header">
        <span class="filename" id="filenameDisplay">‚Äî</span>
        <button type="button" class="change-btn" id="changeBtn">Change video</button>
      </div>
      <div class="video-wrapper">
        <video id="videoPreview" controls playsinline preload="metadata"></video>
      </div>
      <div class="status error" id="statusError"></div>
    </div>

    <div class="step2-section" id="step2Section">
      <span class="step-badge">Step 2 ‚Äî Frame range</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Select frame range</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Use sliders to set the first and last frame of your sequence.</p>
      <div class="frame-range-grid">
        <div class="frame-preview-card">
          <div class="label">First frame</div>
          <div class="preview-box" id="firstFrameBox">
            <span class="placeholder">‚Äî</span>
          </div>
          <div class="slider-row">
            <input type="range" id="firstFrameSlider" min="0" max="0" value="0">
            <span class="frame-num" id="firstFrameNum">0</span>
          </div>
        </div>
        <div class="frame-preview-card">
          <div class="label">Last frame</div>
          <div class="preview-box" id="lastFrameBox">
            <span class="placeholder">‚Äî</span>
          </div>
          <div class="slider-row">
            <input type="range" id="lastFrameSlider" min="0" max="0" value="0">
            <span class="frame-num" id="lastFrameNum">0</span>
          </div>
        </div>
      </div>
      <div class="frame-preview-card overlay-card">
        <div class="label">Compare: first over last</div>
        <div class="preview-box overlay-box" id="overlayBox">
          <img class="overlay-bg" id="overlayBg" alt="">
          <img class="overlay-fg" id="overlayFg" alt="">
          <span class="placeholder" id="overlayPlaceholder">‚Äî</span>
        </div>
      </div>
      <div class="range-summary" id="rangeSummary">
        Range: frame <strong id="rangeStart">0</strong> to <strong id="rangeEnd">0</strong> ‚Äî <strong id="rangeCount">0</strong> frames
      </div>

      <div class="sampling-section">
        <span class="label">Frame sampling</span>
        <div class="sampling-options">
          <label class="sampling-option">
            <input type="radio" name="sampling" value="all" id="samplingAll" checked>
            All frames
          </label>
          <label class="sampling-option">
            <input type="radio" name="sampling" value="everyN" id="samplingEveryN">
            Every Nth frame
          </label>
          <div class="sampling-n-input" id="samplingNRow" style="display:none">
            <span class="looped-preview-info">N =</span>
            <input type="number" id="samplingN" min="2" max="100" value="2">
          </div>
          <label class="sampling-option">
            <input type="radio" name="sampling" value="targetFps" id="samplingTargetFps">
            Target FPS
          </label>
          <div class="sampling-n-input" id="samplingTargetFpsRow" style="display:none">
            <span class="looped-preview-info">FPS</span>
            <input type="number" id="samplingTargetFpsVal" min="5" max="60" value="12" placeholder="12">
          </div>
        </div>
      </div>

      <div class="frame-preview-card looped-preview-card">
        <div class="label">Looped preview</div>
        <div class="preview-box" id="loopedPreviewBox">
          <canvas id="loopedPreviewCanvas" style="max-width:100%;max-height:100%;width:auto;height:auto;display:none;"></canvas>
          <img id="loopedPreviewImg" alt="" style="max-width:100%;max-height:100%;width:auto;height:auto;display:block;">
          <span class="placeholder" id="loopedPreviewPlaceholder">‚Äî</span>
        </div>
        <div class="looped-preview-controls">
          <label>Playback FPS:</label>
          <input type="range" id="loopedPreviewFps" min="5" max="60" value="24">
          <span class="fps-value" id="loopedPreviewFpsVal">24</span>
          <span class="looped-preview-info" id="loopedPreviewInfo">‚Äî frames</span>
        </div>
      </div>
    </div>

    <div class="step3-section" id="step3Section">
      <span class="step-badge">Step 3 ‚Äî Chroma key</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Pick color & remove background</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Click on the first frame to pick the background color. Adjust tolerance to fine-tune removal.</p>
      <div class="chroma-grid">
        <div class="frame-preview-card">
          <div class="label">Click to pick color ¬∑ Wheel zoom ¬∑ Drag to pan</div>
          <div class="chroma-viewport chroma-picker-box" id="chromaPickerBox">
            <div class="chroma-viewport-inner" id="chromaPickerViewport">
              <canvas id="chromaPickerCanvas"></canvas>
            </div>
          </div>
          <div class="chroma-zoom-controls">
            <button type="button" id="chromaPickerZoomOut">‚àí</button>
            <span class="fps-value" id="chromaPickerZoomVal">100%</span>
            <button type="button" id="chromaPickerZoomIn">+</button>
          </div>
        </div>
        <div class="frame-preview-card">
          <div class="label">Result preview ¬∑ Wheel zoom ¬∑ Drag to pan</div>
          <div class="chroma-viewport chroma-preview-box" id="chromaPreviewBox">
            <div class="chroma-viewport-inner" id="chromaPreviewViewport">
              <canvas id="chromaPreviewCanvas"></canvas>
            </div>
          </div>
          <div class="chroma-zoom-controls">
            <button type="button" id="chromaPreviewZoomOut">‚àí</button>
            <span class="fps-value" id="chromaPreviewZoomVal">100%</span>
            <button type="button" id="chromaPreviewZoomIn">+</button>
          </div>
          <div class="chroma-preview-bg-options">
            <label><input type="radio" name="resultPreviewBg" value="transparent" checked> Transparent</label>
            <label><input type="radio" name="resultPreviewBg" value="black"> Black</label>
            <label><input type="radio" name="resultPreviewBg" value="white"> White</label>
            <label><input type="radio" name="resultPreviewBg" value="gray"> Gray</label>
          </div>
        </div>
      </div>
      <div class="chroma-controls">
        <div class="row">
          <div class="color-swatch empty" id="pickedColorSwatch"></div>
          <div>
            <span class="looped-preview-info">Picked color:</span>
            <span id="pickedColorText" style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">‚Äî</span>
          </div>
        </div>
        <div class="row">
          <label class="looped-preview-info">Tolerance:</label>
          <input type="range" id="chromaTolerance" min="0" max="100" value="30">
          <span class="fps-value" id="chromaToleranceVal">30</span>
        </div>
        <div class="row" style="margin-top:1rem; padding-top:1rem; border-top:1px solid var(--border)">
          <label class="sampling-option">
            <input type="checkbox" id="holoRemoverEnabled">
            Holo Remover
          </label>
          <span class="looped-preview-info">Removes color spill (outline) from the removed background</span>
        </div>
        <div class="row" id="holoRemoverRow" style="display:none;align-items:center">
          <label class="looped-preview-info">Strength:</label>
          <input type="range" id="holoRemoverStrength" min="0" max="100" value="80">
          <span class="fps-value" id="holoRemoverStrengthVal">80</span>
        </div>
        <div class="row" style="margin-top:1rem; padding-top:1rem; border-top:1px solid var(--border)">
          <label class="looped-preview-info">Max clusters:</label>
          <input type="range" id="chromaMaxClusters" min="0" max="100" value="0">
          <span class="fps-value" id="chromaMaxClustersVal">‚àû</span>
          <span class="looped-preview-info">0 = keep all, 100 = keep top 100</span>
        </div>
      </div>
    </div>

    <div class="step4-section" id="step4Section">
      <span class="step-badge">Step 4 ‚Äî Processed frames</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Process & browse all frames</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Apply chroma key to all sampled frames and browse the results.</p>
      <div class="row" style="margin-bottom:1rem">
        <button type="button" id="processAllFramesBtn" class="change-btn">Process all frames</button>
        <span class="looped-preview-info" id="processStatus"></span>
      </div>
      <div class="frame-preview-card" id="step4BrowserCard" style="display:none">
        <div class="label">Processed frames ¬∑ Wheel zoom ¬∑ Drag to pan</div>
        <div class="processed-frames-nav">
          <button type="button" id="processedFramePrev">‚Üê</button>
          <span class="fps-value" id="processedFrameInfo">1 / 1</span>
          <button type="button" id="processedFrameNext">‚Üí</button>
        </div>
        <div class="chroma-viewport chroma-preview-box step4-viewport" id="step4Viewport">
          <div class="chroma-viewport-inner" id="step4ViewportInner">
            <img id="step4FrameImg" alt="" style="display:block;width:100%;height:100%;object-fit:contain;">
          </div>
        </div>
        <div class="chroma-zoom-controls">
          <button type="button" id="step4ZoomOut">‚àí</button>
          <span class="fps-value" id="step4ZoomVal">100%</span>
          <button type="button" id="step4ZoomIn">+</button>
        </div>
        <div class="chroma-preview-bg-options">
          <label><input type="radio" name="step4PreviewBg" value="transparent" checked> Transparent</label>
          <label><input type="radio" name="step4PreviewBg" value="black"> Black</label>
          <label><input type="radio" name="step4PreviewBg" value="white"> White</label>
          <label><input type="radio" name="step4PreviewBg" value="gray"> Gray</label>
        </div>
      </div>
    </div>

    <div class="step5-section" id="step5Section">
      <span class="step-badge">Step 5 ‚Äî Looping (optional)</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Generate intermediate frames</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Create smooth transitions between first and last frame for seamless looping.</p>
      <div class="row" style="margin-bottom:1rem">
        <label class="sampling-option">
          <input type="checkbox" id="step5GenerateEnabled">
          Need generate frame between first and end
        </label>
      </div>
      <div class="step5-content" id="step5Content">
        <div class="row" style="margin-bottom:1rem">
          <label class="looped-preview-info">Number of frames:</label>
          <input type="number" id="step5FrameCount" min="1" max="20" value="3">
          <button type="button" id="step5GenerateBtn" class="change-btn">Generate</button>
        </div>
        <div class="chroma-grid" style="margin-top:1rem">
          <div class="frame-preview-card">
            <div class="label">Generated frames ¬∑ Wheel zoom ¬∑ Drag to pan</div>
            <div class="processed-frames-nav">
              <button type="button" id="loopedFramePrev">‚Üê</button>
              <span class="fps-value" id="loopedFrameInfo">1 / 1</span>
              <button type="button" id="loopedFrameNext">‚Üí</button>
            </div>
            <div class="chroma-viewport chroma-preview-box" id="step5Viewport">
              <div class="chroma-viewport-inner" id="step5ViewportInner">
                <img id="step5FrameImg" alt="" style="display:block;width:100%;height:100%;object-fit:contain;">
              </div>
            </div>
            <div class="chroma-zoom-controls">
              <button type="button" id="step5ZoomOut">‚àí</button>
              <span class="fps-value" id="step5ZoomVal">100%</span>
              <button type="button" id="step5ZoomIn">+</button>
            </div>
            <div class="chroma-preview-bg-options">
              <label><input type="radio" name="step5PreviewBg" value="transparent" checked> Transparent</label>
              <label><input type="radio" name="step5PreviewBg" value="black"> Black</label>
              <label><input type="radio" name="step5PreviewBg" value="white"> White</label>
              <label><input type="radio" name="step5PreviewBg" value="gray"> Gray</label>
            </div>
          </div>
          <div class="frame-preview-card overlay-card">
            <div class="label">Overlay: first + intermediate + last</div>
            <div class="preview-box overlay-box step5-overlay-box">
              <img class="overlay-bg" id="step5OverlayBg" alt="">
              <img class="overlay-fg" id="step5OverlayMid" alt="">
              <img class="overlay-fg" id="step5OverlayFg" alt="">
            </div>
          </div>
        </div>
        <div class="frame-preview-card" style="margin-top:1.5rem" id="step5PlaybackCard">
          <div class="label">Loop transition preview ¬∑ (last‚àíN)‚Ä¶last ‚Üí generated ‚Üí first‚Ä¶(first+N)</div>
          <div class="row" style="padding:1rem; align-items:center; flex-wrap:wrap; gap:1rem; border-bottom:1px solid var(--border)">
            <label class="looped-preview-info">Context frames N:</label>
            <input type="number" id="step5ContextN" min="1" max="50" value="5" style="width:4rem; padding:0.35rem 0.5rem; background:var(--bg); border:1px solid var(--border); border-radius:var(--radius-sm); color:var(--text); font-family:'JetBrains Mono',monospace;">
            <label class="looped-preview-info">FPS:</label>
            <input type="number" id="step5PlaybackFps" min="5" max="60" value="24" style="width:4rem; padding:0.35rem 0.5rem; background:var(--bg); border:1px solid var(--border); border-radius:var(--radius-sm); color:var(--text); font-family:'JetBrains Mono',monospace;">
            <button type="button" id="step5PlayBtn" class="change-btn">Play</button>
            <span class="looped-preview-info" id="step5PlaybackInfo">‚Äî</span>
          </div>
          <div class="preview-box" id="step5PlaybackBox" style="min-height:160px">
            <canvas id="step5PlaybackCanvas" style="max-width:100%;max-height:100%;width:auto;height:auto;display:none;"></canvas>
            <img id="step5PlaybackImg" alt="" style="max-width:100%;max-height:100%;width:auto;height:auto;display:block;">
            <span class="placeholder" id="step5PlaybackPlaceholder">Generate frames, then set N and press Play</span>
          </div>
        </div>
      </div>
    </div>

    <div class="step6-section" id="step6Section">
      <span class="step-badge">Step 6 ‚Äî Export Sprite Sheet</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Save PNG sprite sheet</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Export all frames as a single sprite sheet (power-of-2 dimensions).</p>
      <div class="frame-preview-card">
        <div class="row" style="align-items:center; flex-wrap:wrap; gap:1rem; margin-bottom:1rem">
          <label class="looped-preview-info">Frame size (one side):</label>
          <input type="range" id="step6FrameSize" min="16" max="512" value="64" step="1">
          <span class="fps-value" id="step6FrameSizeVal">64</span>
          <span class="looped-preview-info" id="step6FrameDims">‚Äî √ó ‚Äî</span>
        </div>
        <div class="row">
          <button type="button" id="step6ExportBtn" class="change-btn">Export to sprite sheet</button>
          <span class="looped-preview-info" id="step6ExportStatus"></span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const loadingZone = document.getElementById('loadingZone');
    const statusLoading = document.getElementById('statusLoading');
    const previewSection = document.getElementById('previewSection');
    const filenameDisplay = document.getElementById('filenameDisplay');
    const videoPreview = document.getElementById('videoPreview');
    const changeBtn = document.getElementById('changeBtn');
    const statusError = document.getElementById('statusError');

    function showUpload() {
      uploadZone.style.display = 'block';
      loadingZone.classList.remove('visible');
      previewSection.classList.remove('visible');
      statusError.classList.remove('visible');
    }

    function showLoading() {
      uploadZone.style.display = 'none';
      loadingZone.classList.add('visible');
      statusLoading.classList.add('visible');
      previewSection.classList.remove('visible');
    }

    function showPreview(filename, url, videoId) {
      loadingZone.classList.remove('visible');
      previewSection.classList.add('visible');
      filenameDisplay.textContent = filename;
      videoPreview.src = url;
      statusError.classList.remove('visible');
      uploadZone.style.display = 'block';
      initStep2(videoId);
    }

    function showError(msg) {
      loadingZone.classList.remove('visible');
      statusLoading.classList.remove('visible');
      uploadZone.style.display = 'block';
      statusError.textContent = msg;
      statusError.classList.add('visible');
    }

    async function uploadFile(file) {
      if (!file || !file.type.startsWith('video/')) {
        showError('Please select a valid video file.');
        return;
      }

      showLoading();
      const formData = new FormData();
      formData.append('file', file);

      try {
        const res = await fetch('/api/upload', {
          method: 'POST',
          body: formData,
        });

        const data = await res.json().catch(() => ({}));

        if (!res.ok) {
          showError(data.detail || `Upload failed (${res.status})`);
          return;
        }

        const base = window.location.origin;
        const videoUrl = data.url.startsWith('http') ? data.url : base + data.url;
        showPreview(data.filename, videoUrl, data.id);
      } catch (err) {
        showError('Network error. Is the server running?');
        console.error(err);
      }
    }

    function onFileSelected(e) {
      const file = e.target?.files?.[0] || e.dataTransfer?.files?.[0];
      if (file) uploadFile(file);
      fileInput.value = '';
      uploadZone.classList.remove('drag-over');
    }

    uploadZone.addEventListener('click', (e) => {
      if (e.target !== fileInput) fileInput.click();
    });

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('drag-over');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('drag-over');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      onFileSelected({ target: null, dataTransfer: e.dataTransfer });
    });

    fileInput.addEventListener('change', onFileSelected);

    changeBtn.addEventListener('click', () => {
      if (loopedPreviewInterval) {
        clearInterval(loopedPreviewInterval);
        loopedPreviewInterval = null;
      }
      videoPreview.pause();
      videoPreview.src = '';
      frameCache.forEach(url => URL.revokeObjectURL(url));
      frameCache = [];
      (processedFrameCache || []).forEach(url => URL.revokeObjectURL(url));
      processedFrameCache = [];
      step2Section.classList.remove('visible');
      step3Section.classList.remove('visible');
      step4Section.classList.remove('visible');
      step5Section.classList.remove('visible');
      step6Section.classList.remove('visible');
      if (step5PlaybackInterval) {
        clearInterval(step5PlaybackInterval);
        step5PlaybackInterval = null;
      }
      (loopedFrameCache || []).forEach(url => URL.revokeObjectURL(url));
      loopedFrameCache = [];
      showUpload();
      fileInput.click();
    });

    // Step 2 ‚Äî Frame range (all frames cached, instant preview on slider move)
    const step2Section = document.getElementById('step2Section');
    const firstFrameSlider = document.getElementById('firstFrameSlider');
    const lastFrameSlider = document.getElementById('lastFrameSlider');
    const firstFrameNum = document.getElementById('firstFrameNum');
    const lastFrameNum = document.getElementById('lastFrameNum');
    const firstFrameBox = document.getElementById('firstFrameBox');
    const lastFrameBox = document.getElementById('lastFrameBox');
    const rangeStart = document.getElementById('rangeStart');
    const rangeEnd = document.getElementById('rangeEnd');
    const rangeCount = document.getElementById('rangeCount');
    const overlayBg = document.getElementById('overlayBg');
    const overlayFg = document.getElementById('overlayFg');
    const overlayPlaceholder = document.getElementById('overlayPlaceholder');

    const step3Section = document.getElementById('step3Section');
    const chromaPickerCanvas = document.getElementById('chromaPickerCanvas');
    const chromaPreviewCanvas = document.getElementById('chromaPreviewCanvas');
    const chromaPickerBox = document.getElementById('chromaPickerBox');
    const pickedColorSwatch = document.getElementById('pickedColorSwatch');
    const pickedColorText = document.getElementById('pickedColorText');
    const chromaToleranceInput = document.getElementById('chromaTolerance');
    const chromaToleranceVal = document.getElementById('chromaToleranceVal');

    let videoId = null;
    let frameCache = []; // blob URLs for each frame
    let videoFps = 30; // original video FPS from metadata
    let loopedPreviewInterval = null;
    let chromaPickedColor = null; // { r, g, b }
    let chromaSourceImg = null;   // loaded Image for first frame

    function setPreviewFromCache(boxEl, index) {
      if (index < 0 || index >= frameCache.length) return;
      const placeholder = boxEl.querySelector('.placeholder');
      let img = boxEl.querySelector('img');
      if (placeholder) placeholder.style.display = 'none';
      if (!img) {
        img = document.createElement('img');
        img.alt = 'Frame ' + index;
        boxEl.appendChild(img);
      }
      img.src = frameCache[index];
    }

    function updateFirstFrame() {
      const idx = parseInt(firstFrameSlider.value, 10);
      firstFrameNum.textContent = idx;
      setPreviewFromCache(firstFrameBox, idx);
      const lastVal = parseInt(lastFrameSlider.value, 10);
      if (idx > lastVal) {
        lastFrameSlider.value = idx;
        lastFrameNum.textContent = idx;
        setPreviewFromCache(lastFrameBox, idx);
      }
      updateRangeSummary();
      updateOverlay();
      updateLoopedPreview();
      updateChromaPicker();
    }

    function updateLastFrame() {
      const idx = parseInt(lastFrameSlider.value, 10);
      lastFrameNum.textContent = idx;
      setPreviewFromCache(lastFrameBox, idx);
      const firstVal = parseInt(firstFrameSlider.value, 10);
      if (idx < firstVal) {
        firstFrameSlider.value = idx;
        firstFrameNum.textContent = idx;
        setPreviewFromCache(firstFrameBox, idx);
      }
      updateRangeSummary();
      updateOverlay();
      updateLoopedPreview();
    }

    function updateRangeSummary() {
      const first = parseInt(firstFrameSlider.value, 10);
      const last = parseInt(lastFrameSlider.value, 10);
      const count = Math.max(0, last - first + 1);
      rangeStart.textContent = first;
      rangeEnd.textContent = last;
      rangeCount.textContent = count;
    }

    function updateOverlay() {
      if (frameCache.length === 0) return;
      const firstIdx = parseInt(firstFrameSlider.value, 10);
      const lastIdx = parseInt(lastFrameSlider.value, 10);
      if (firstIdx < 0 || firstIdx >= frameCache.length || lastIdx < 0 || lastIdx >= frameCache.length) return;
      overlayPlaceholder.style.display = 'none';
      overlayBg.src = frameCache[lastIdx];
      overlayFg.src = frameCache[firstIdx];
    }

    function getSampledIndices() {
      const first = parseInt(firstFrameSlider.value, 10);
      const last = parseInt(lastFrameSlider.value, 10);
      const indices = [];
      if (first > last) return indices;
      const rangeCount = last - first + 1;
      const useEveryN = document.getElementById('samplingEveryN').checked;
      const useTargetFps = document.getElementById('samplingTargetFps').checked;
      if (useTargetFps) {
        const targetFps = Math.max(5, Math.min(60, parseInt(document.getElementById('samplingTargetFpsVal').value, 10) || 12));
        const targetCount = Math.max(1, Math.round(rangeCount * targetFps / videoFps));
        for (let i = 0; i < targetCount; i++) {
          const idx = first + Math.round(i * (last - first) / Math.max(1, targetCount - 1));
          indices.push(Math.min(idx, last));
        }
      } else if (useEveryN) {
        const n = Math.max(2, parseInt(document.getElementById('samplingN').value, 10) || 2);
        for (let i = first; i <= last; i += n) indices.push(i);
      } else {
        for (let i = first; i <= last; i++) indices.push(i);
      }
      return indices;
    }

    let loopedPreviewPreloaded = [];
    let loopedPreviewEpoch = 0;

    async function startLoopedPreview() {
      if (loopedPreviewInterval) clearInterval(loopedPreviewInterval);
      const indices = getSampledIndices();
      const canvas = document.getElementById('loopedPreviewCanvas');
      const loopedImg = document.getElementById('loopedPreviewImg');
      const loopedPlaceholder = document.getElementById('loopedPreviewPlaceholder');
      const loopedInfo = document.getElementById('loopedPreviewInfo');
      if (indices.length === 0 || frameCache.length === 0) {
        loopedPlaceholder.textContent = '‚Äî';
        loopedPlaceholder.style.display = 'inline';
        loopedImg.style.display = 'block';
        canvas.style.display = 'none';
        loopedImg.src = '';
        loopedInfo.textContent = '0 frames';
        return;
      }
      const epoch = ++loopedPreviewEpoch;
      loopedPlaceholder.textContent = 'Preloading‚Ä¶';
      loopedPlaceholder.style.display = 'inline';
      loopedImg.style.display = 'none';
      canvas.style.display = 'none';
      const preloaded = [];
      for (let k = 0; k < indices.length; k++) {
        if (epoch !== loopedPreviewEpoch) return;
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = frameCache[indices[k]];
        });
        if (epoch !== loopedPreviewEpoch) return;
        preloaded.push(img);
      }
      loopedPreviewPreloaded = preloaded;
      loopedPlaceholder.style.display = 'none';
      canvas.style.display = 'block';
      canvas.width = preloaded[0].naturalWidth;
      canvas.height = preloaded[0].naturalHeight;
      const ctx = canvas.getContext('2d');
      let idx = 0;
      const tick = () => {
        if (loopedPreviewPreloaded.length === 0) return;
        ctx.drawImage(loopedPreviewPreloaded[idx], 0, 0);
        idx = (idx + 1) % loopedPreviewPreloaded.length;
      };
      tick();
      loopedInfo.textContent = indices.length + ' frames';
      const fps = parseInt(document.getElementById('loopedPreviewFps').value, 10) || 24;
      const msPerFrame = 1000 / Math.max(1, fps);
      loopedPreviewInterval = setInterval(tick, msPerFrame);
    }

    function updateLoopedPreview() {
      startLoopedPreview();
    }

    async function initStep2(id) {
      videoId = id;
      step2Section.classList.add('visible');
      const summaryEl = step2Section.querySelector('.range-summary');
      firstFrameBox.innerHTML = '<span class="placeholder">Loading frames‚Ä¶</span>';
      lastFrameBox.innerHTML = '<span class="placeholder">Loading frames‚Ä¶</span>';
      try {
        const metaRes = await fetch(`/api/video/${id}/metadata`);
        if (!metaRes.ok) throw new Error('Failed to load metadata');
        const meta = await metaRes.json();
        const totalFrames = Math.max(1, meta.frame_count || 1);
        const maxIdx = totalFrames - 1;

        summaryEl.textContent = `Loading ${totalFrames} frames‚Ä¶`;
        const zipRes = await fetch(`/api/video/${id}/frames`);
        if (!zipRes.ok) throw new Error('Failed to load frames');
        const zipBlob = await zipRes.blob();
        const zip = await JSZip.loadAsync(zipBlob);
        const names = Object.keys(zip.files).filter(n => n.endsWith('.png')).sort();
        frameCache = [];
        for (const name of names) {
          const blob = await zip.files[name].async('blob');
          frameCache.push(URL.createObjectURL(blob));
        }
        const loadedCount = frameCache.length;
        const safeMaxIdx = Math.min(maxIdx, loadedCount - 1);

        firstFrameSlider.min = 0;
        firstFrameSlider.max = safeMaxIdx;
        firstFrameSlider.value = 0;
        lastFrameSlider.min = 0;
        lastFrameSlider.max = safeMaxIdx;
        lastFrameSlider.value = safeMaxIdx;
        firstFrameNum.textContent = '0';
        lastFrameNum.textContent = String(safeMaxIdx);
        updateRangeSummary();

        firstFrameBox.innerHTML = '';
        lastFrameBox.innerHTML = '';
        setPreviewFromCache(firstFrameBox, 0);
        setPreviewFromCache(lastFrameBox, safeMaxIdx);
        overlayPlaceholder.style.display = 'none';
        overlayBg.src = frameCache[safeMaxIdx];
        overlayFg.src = frameCache[0];
        videoFps = meta.fps || 30;
        document.getElementById('samplingNRow').style.display = document.getElementById('samplingEveryN').checked ? 'flex' : 'none';
        document.getElementById('samplingTargetFpsRow').style.display = document.getElementById('samplingTargetFps').checked ? 'flex' : 'none';
        document.getElementById('loopedPreviewFpsVal').textContent = document.getElementById('loopedPreviewFps').value;
        startLoopedPreview();
        initStep3();
      } catch (e) {
        summaryEl.innerHTML = 'Could not load frames: ' + (e.message || 'Unknown error');
        firstFrameBox.innerHTML = '<span class="placeholder">Error</span>';
        lastFrameBox.innerHTML = '<span class="placeholder">Error</span>';
      }
    }

    const ZOOM_MIN = 25;
    const ZOOM_MAX = 500;

    function initViewport(viewportEl, innerEl, canvas, zoomValEl, state, onPickClick) {
      function applyTransform() {
        const s = state.scale / 100;
        innerEl.style.transform = `translate(${state.offsetX}px,${state.offsetY}px) scale(${s})`;
        zoomValEl.textContent = Math.round(state.scale) + '%';
      }

      function screenToContent(sx, sy) {
        const rect = viewportEl.getBoundingClientRect();
        const s = state.scale / 100;
        return {
          x: (sx - rect.left - state.offsetX) / s,
          y: (sy - rect.top - state.offsetY) / s
        };
      }

      function centerContent() {
        const rect = viewportEl.getBoundingClientRect();
        const s = state.scale / 100;
        const cw = canvas.width, ch = canvas.height;
        state.offsetX = (rect.width - cw * s) / 2;
        state.offsetY = (rect.height - ch * s) / 2;
        applyTransform();
      }

      function zoomAt(centerX, centerY, delta) {
        const rect = viewportEl.getBoundingClientRect();
        const mx = centerX - rect.left;
        const my = centerY - rect.top;
        const oldScale = state.scale / 100;
        const newScale = Math.max(ZOOM_MIN / 100, Math.min(ZOOM_MAX / 100, oldScale * delta));
        state.scale = newScale * 100;
        state.offsetX = mx - (mx - state.offsetX) / oldScale * newScale;
        state.offsetY = my - (my - state.offsetY) / oldScale * newScale;
        applyTransform();
      }

      let dragStart = null;

      viewportEl.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomAt(e.clientX, e.clientY, delta);
      }, { passive: false });

      viewportEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        dragStart = { x: e.clientX, y: e.clientY, ox: state.offsetX, oy: state.offsetY };
        viewportEl.classList.add('dragging');
      });
      viewportEl.addEventListener('contextmenu', (e) => e.preventDefault());

      viewportEl.addEventListener('mousemove', (e) => {
        if (dragStart) {
          state.offsetX = dragStart.ox + (e.clientX - dragStart.x);
          state.offsetY = dragStart.oy + (e.clientY - dragStart.y);
          applyTransform();
        }
      });

      const onMouseUp = (e) => {
        if (e.button !== 0) return;
        if (dragStart && onPickClick) {
          const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
          if (dx * dx + dy * dy < 16) {
            const p = screenToContent(dragStart.x, dragStart.y);
            onPickClick(Math.floor(p.x), Math.floor(p.y));
          }
        }
        dragStart = null;
        viewportEl.classList.remove('dragging');
      };

      viewportEl.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mousemove', (e) => {
        if (dragStart) {
          state.offsetX = dragStart.ox + (e.clientX - dragStart.x);
          state.offsetY = dragStart.oy + (e.clientY - dragStart.y);
          applyTransform();
        }
      });

      applyTransform();
      return { applyTransform, centerContent, zoomAt, screenToContent, state };
    }

    const pickerViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    const previewViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    let pickerViewport, previewViewport;

    function loadChromaFrame() {
      const indices = getSampledIndices();
      if (indices.length === 0 || frameCache.length === 0) return;
      const firstIdx = indices[0];
      const img = new Image();
      img.onload = () => {
        chromaSourceImg = img;
        const w = img.naturalWidth;
        const h = img.naturalHeight;
        chromaPickerCanvas.width = w;
        chromaPickerCanvas.height = h;
        chromaPreviewCanvas.width = w;
        chromaPreviewCanvas.height = h;
        const ctx = chromaPickerCanvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);
        chromaPickedColor = null;
        pickedColorSwatch.classList.add('empty');
        pickedColorSwatch.style.backgroundColor = '';
        pickedColorText.textContent = '‚Äî click to pick';
        applyChromaPreview();
        pickerViewportState.scale = 100;
        pickerViewportState.offsetX = 0;
        pickerViewportState.offsetY = 0;
        previewViewportState.scale = 100;
        previewViewportState.offsetX = 0;
        previewViewportState.offsetY = 0;
        if (pickerViewport) pickerViewport.centerContent();
        if (previewViewport) previewViewport.centerContent();
      };
      img.src = frameCache[firstIdx];
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function applyClusterFilter(data, width, height, maxClusters) {
      if (maxClusters <= 0) return;
      const len = width * height;
      const clusterId = new Int32Array(len);
      clusterId.fill(-1);
      for (let i = 0; i < len; i++) {
        if (data[i * 4 + 3] > 0) clusterId[i] = 0;
      }
      const clusters = [];
      let nextId = 1;
      const stack = [];
      const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
      const dy = [-1, -1, -1, 0, 0, 1, 1, 1];
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (clusterId[idx] !== 0) continue;
          let size = 0;
          stack.length = 0;
          stack.push([x, y]);
          clusterId[idx] = nextId;
          size++;
          while (stack.length > 0) {
            const [cx, cy] = stack.pop();
            for (let d = 0; d < 8; d++) {
              const nx = cx + dx[d], ny = cy + dy[d];
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              const nidx = ny * width + nx;
              if (clusterId[nidx] === 0) {
                clusterId[nidx] = nextId;
                size++;
                stack.push([nx, ny]);
              }
            }
          }
          clusters.push({ id: nextId, size });
          nextId++;
        }
      }
      clusters.sort((a, b) => b.size - a.size);
      const keepIds = new Set(clusters.slice(0, maxClusters).map(c => c.id));
      for (let i = 0; i < len; i++) {
        const cid = clusterId[i];
        if (cid > 0 && !keepIds.has(cid)) data[i * 4 + 3] = 0;
      }
    }

    function applyDespill(data, keyR, keyG, keyB, strength) {
      const s = strength / 100;
      for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] === 0) continue;
        let r = data[i], g = data[i + 1], b = data[i + 2];
        let spill = 0;
        if (keyG >= keyR && keyG >= keyB) {
          spill = Math.max(0, g - Math.max(r, b));
          g = Math.round(g - spill * s);
        } else if (keyB >= keyR && keyB >= keyG) {
          spill = Math.max(0, b - Math.max(r, g));
          b = Math.round(b - spill * s);
        } else if (keyR >= keyG && keyR >= keyB) {
          spill = Math.max(0, r - Math.max(g, b));
          r = Math.round(r - spill * s);
        }
        data[i] = Math.max(0, Math.min(255, r));
        data[i + 1] = Math.max(0, Math.min(255, g));
        data[i + 2] = Math.max(0, Math.min(255, b));
      }
    }

    function applyChromaPreview() {
      if (!chromaSourceImg) return;
      const ctx = chromaPreviewCanvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(chromaSourceImg, 0, 0);
      if (chromaPickedColor === null) return;
      const imgData = ctx.getImageData(0, 0, chromaPreviewCanvas.width, chromaPreviewCanvas.height);
      const data = imgData.data;
      const kr = chromaPickedColor.r, kg = chromaPickedColor.g, kb = chromaPickedColor.b;
      const tol = parseInt(chromaToleranceInput.value, 10) || 30;
      const threshold = (tol / 100) * 442;
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - kr, dg = data[i + 1] - kg, db = data[i + 2] - kb;
        const dist = Math.sqrt(dr * dr + dg * dg + db * db);
        if (dist <= threshold) data[i + 3] = 0;
      }
      const holoEnabled = document.getElementById('holoRemoverEnabled').checked;
      if (holoEnabled) {
        const holoStrength = parseInt(document.getElementById('holoRemoverStrength').value, 10) || 80;
        applyDespill(data, kr, kg, kb, holoStrength);
      }
      const maxClusters = parseInt(document.getElementById('chromaMaxClusters').value, 10) || 0;
      if (maxClusters > 0) {
        applyClusterFilter(data, chromaPreviewCanvas.width, chromaPreviewCanvas.height, maxClusters);
      }
      ctx.putImageData(imgData, 0, 0);
    }

    function onChromaPick(x, y) {
      if (!chromaSourceImg || frameCache.length === 0) return;
      const w = chromaPickerCanvas.width, h = chromaPickerCanvas.height;
      if (x < 0 || x >= w || y < 0 || y >= h) return;
      const ctx = chromaPickerCanvas.getContext('2d', { willReadFrequently: true });
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      chromaPickedColor = { r: pixel[0], g: pixel[1], b: pixel[2] };
      pickedColorSwatch.classList.remove('empty');
      pickedColorSwatch.style.backgroundColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
      pickedColorText.textContent = rgbToHex(pixel[0], pixel[1], pixel[2]) + ' rgb(' + pixel[0] + ',' + pixel[1] + ',' + pixel[2] + ')';
      applyChromaPreview();
    }

    function updateChromaPicker() {
      if (!step3Section.classList.contains('visible')) return;
      loadChromaFrame();
    }

    const step4Section = document.getElementById('step4Section');
    const step6Section = document.getElementById('step6Section');

    function initStep3() {
      step3Section.classList.add('visible');
      step4Section.classList.add('visible');
      step5Section.classList.add('visible');
      step6Section.classList.add('visible');
      chromaToleranceVal.textContent = chromaToleranceInput.value;
      document.getElementById('chromaMaxClustersVal').textContent = 
        parseInt(document.getElementById('chromaMaxClusters').value, 10) === 0 ? '‚àû' : document.getElementById('chromaMaxClusters').value;
      loadChromaFrame();
    }

    function processFrameToData(img, w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w;
      canvas.height = h;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      const imgData = ctx.getImageData(0, 0, w, h);
      const data = imgData.data;
      if (chromaPickedColor === null) return null;
      const kr = chromaPickedColor.r, kg = chromaPickedColor.g, kb = chromaPickedColor.b;
      const tol = parseInt(chromaToleranceInput.value, 10) || 30;
      const threshold = (tol / 100) * 442;
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - kr, dg = data[i + 1] - kg, db = data[i + 2] - kb;
        const dist = Math.sqrt(dr * dr + dg * dg + db * db);
        if (dist <= threshold) data[i + 3] = 0;
      }
      if (document.getElementById('holoRemoverEnabled').checked) {
        applyDespill(data, kr, kg, kb, parseInt(document.getElementById('holoRemoverStrength').value, 10) || 80);
      }
      const maxClusters = parseInt(document.getElementById('chromaMaxClusters').value, 10) || 0;
      if (maxClusters > 0) applyClusterFilter(data, w, h, maxClusters);
      ctx.putImageData(imgData, 0, 0);
      return canvas;
    }

    let processedFrameCache = [];
    let processedFrameIdx = 0;

    async function processAllFrames() {
      if (chromaPickedColor === null) {
        document.getElementById('processStatus').textContent = 'Pick a color first.';
        return;
      }
      const indices = getSampledIndices();
      if (indices.length === 0 || frameCache.length === 0) {
        document.getElementById('processStatus').textContent = 'No frames to process.';
        return;
      }
      const statusEl = document.getElementById('processStatus');
      const btn = document.getElementById('processAllFramesBtn');
      btn.disabled = true;
      processedFrameCache.forEach(url => URL.revokeObjectURL(url));
      processedFrameCache = [];
      const w = chromaPickerCanvas.width, h = chromaPickerCanvas.height;
      for (let i = 0; i < indices.length; i++) {
        statusEl.textContent = `Processing frame ${i + 1} / ${indices.length}‚Ä¶`;
        await new Promise(r => setTimeout(r, 0));
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = frameCache[indices[i]];
        });
        const canvas = processFrameToData(img, w, h);
        if (!canvas) continue;
        const blob = await new Promise(r => canvas.toBlob(r, 'image/png'));
        processedFrameCache.push(URL.createObjectURL(blob));
      }
      processedFrameIdx = 0;
      statusEl.textContent = `Done. ${processedFrameCache.length} frames processed.`;
      btn.disabled = false;
      document.getElementById('step4BrowserCard').style.display = 'block';
      updateStep6FrameDims();
      initStep4Viewport();
      showProcessedFrame(0);
    }

    const step4ViewportEl = document.getElementById('step4Viewport');
    const step4ViewportInner = document.getElementById('step4ViewportInner');
    const step4ViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    let step4Viewport = null;

    function initStep4Viewport() {
      if (step4Viewport) return;
      const dimCanvas = document.createElement('canvas');
      dimCanvas.width = chromaPickerCanvas.width;
      dimCanvas.height = chromaPickerCanvas.height;
      step4ViewportInner.style.width = dimCanvas.width + 'px';
      step4ViewportInner.style.height = dimCanvas.height + 'px';
      step4Viewport = initViewport(
        step4ViewportEl,
        step4ViewportInner,
        dimCanvas,
        document.getElementById('step4ZoomVal'),
        step4ViewportState,
        null
      );
    }

    function showProcessedFrame(idx) {
      if (processedFrameCache.length === 0) return;
      processedFrameIdx = ((idx % processedFrameCache.length) + processedFrameCache.length) % processedFrameCache.length;
      const img = document.getElementById('step4FrameImg');
      img.src = processedFrameCache[processedFrameIdx];
      document.getElementById('processedFrameInfo').textContent = `${processedFrameIdx + 1} / ${processedFrameCache.length}`;
      if (step4Viewport) step4Viewport.centerContent();
    }

    let loopedFrameCache = [];
    let loopedFrameIdx = 0;
    let step5Viewport = null;
    const step5ViewportEl = document.getElementById('step5Viewport');
    const step5ViewportInner = document.getElementById('step5ViewportInner');
    const step5ViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    const step5Section = document.getElementById('step5Section');

    async function loadImageData(url) {
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = url;
      });
      const canvas = document.createElement('canvas');
      canvas.width = img.naturalWidth;
      canvas.height = img.naturalHeight;
      const ctx = canvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(img, 0, 0);
      return ctx.getImageData(0, 0, canvas.width, canvas.height);
    }

    async function generateLoopFrames() {
      if (processedFrameCache.length < 2) {
        document.getElementById('processStatus').textContent = 'Need at least 2 processed frames.';
        return;
      }
      const btn = document.getElementById('step5GenerateBtn');
      btn.disabled = true;
      const statusEl = document.getElementById('processStatus');
      try {
        statusEl.textContent = 'Computing optical flow‚Ä¶';
        const n = Math.max(1, Math.min(20, parseInt(document.getElementById('step5FrameCount').value, 10) || 3));
        loopedFrameCache.forEach(url => URL.revokeObjectURL(url));
        loopedFrameCache = [];

        const blobFirst = await fetch(processedFrameCache[0]).then(r => r.blob());
        const blobLast = await fetch(processedFrameCache[processedFrameCache.length - 1]).then(r => r.blob());
        const form = new FormData();
        form.append('first', blobFirst, 'first.png');
        form.append('last', blobLast, 'last.png');
        const tol = parseInt(document.getElementById('chromaTolerance').value, 10) || 30;
        const holoOn = document.getElementById('holoRemoverEnabled').checked;
        const holoStr = parseInt(document.getElementById('holoRemoverStrength').value, 10) || 80;
        const maxClust = parseInt(document.getElementById('chromaMaxClusters').value, 10) || 0;
        const qs = new URLSearchParams({
          num_frames: String(n),
          chroma_tolerance: String(tol),
          chroma_holo_enabled: String(holoOn),
          chroma_holo_strength: String(holoStr),
          chroma_max_clusters: String(maxClust),
        });
        const res = await fetch(`/api/interpolate-frames?${qs}`, {
          method: 'POST',
          body: form,
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({}));
          throw new Error(err.detail || `Server error ${res.status}`);
        }
        const zipBlob = await res.blob();
        const zip = await JSZip.loadAsync(zipBlob);
        const names = ['first.png'];
        for (let i = 1; i <= n; i++) names.push(`interp_${String(i).padStart(3, '0')}.png`);
        names.push('last.png');
        for (const name of names) {
          const entry = zip.files[name];
          if (!entry) continue;
          const blob = await entry.async('blob');
          loopedFrameCache.push(URL.createObjectURL(blob));
        }

        loopedFrameIdx = 0;
        initStep5Viewport();
        showLoopedFrame(0);
        const midIdx = Math.floor(loopedFrameCache.length / 2);
        document.getElementById('step5OverlayBg').src = loopedFrameCache[loopedFrameCache.length - 1];
        document.getElementById('step5OverlayMid').src = loopedFrameCache[midIdx];
        document.getElementById('step5OverlayFg').src = loopedFrameCache[0];
        statusEl.textContent = '';
        updateStep6FrameDims();
      } catch (e) {
        statusEl.textContent = 'Error: ' + (e.message || 'Failed to generate frames');
      } finally {
        btn.disabled = false;
      }
    }

    function initStep5Viewport() {
      if (step5Viewport) return;
      const dimCanvas = document.createElement('canvas');
      dimCanvas.width = chromaPickerCanvas.width;
      dimCanvas.height = chromaPickerCanvas.height;
      step5ViewportInner.style.width = dimCanvas.width + 'px';
      step5ViewportInner.style.height = dimCanvas.height + 'px';
      step5Viewport = initViewport(
        step5ViewportEl,
        step5ViewportInner,
        dimCanvas,
        document.getElementById('step5ZoomVal'),
        step5ViewportState,
        null
      );
    }

    function showLoopedFrame(idx) {
      if (loopedFrameCache.length === 0) return;
      loopedFrameIdx = ((idx % loopedFrameCache.length) + loopedFrameCache.length) % loopedFrameCache.length;
      document.getElementById('step5FrameImg').src = loopedFrameCache[loopedFrameIdx];
      document.getElementById('loopedFrameInfo').textContent = `${loopedFrameIdx + 1} / ${loopedFrameCache.length}`;
      if (step5Viewport) step5Viewport.centerContent();
    }

    let step5PlaybackInterval = null;
    let step5PlaybackSequence = [];
    let step5PlaybackPreloaded = [];
    let step5PlaybackIdx = 0;

    function buildStep5PlaybackSequence() {
      const seq = [];
      const total = processedFrameCache.length;
      if (total === 0) return seq;
      const lastIdx = total - 1;
      const N = Math.max(1, Math.min(50, parseInt(document.getElementById('step5ContextN').value, 10) || 5));
      const startIdx = Math.max(0, lastIdx - N);
      for (let i = startIdx; i <= lastIdx; i++) seq.push(processedFrameCache[i]);
      if (loopedFrameCache.length > 2) {
        for (let i = loopedFrameCache.length - 2; i >= 1; i--) seq.push(loopedFrameCache[i]);
      }
      const endIdx = Math.min(N, lastIdx);
      for (let i = 0; i <= endIdx; i++) seq.push(processedFrameCache[i]);
      return seq;
    }

    function step5PlaybackTick() {
      if (step5PlaybackPreloaded.length === 0) return;
      const canvas = document.getElementById('step5PlaybackCanvas');
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      const idx = step5PlaybackIdx % step5PlaybackPreloaded.length;
      ctx.drawImage(step5PlaybackPreloaded[idx], 0, 0);
      document.getElementById('step5PlaybackInfo').textContent = `${idx + 1} / ${step5PlaybackPreloaded.length}`;
      step5PlaybackIdx = (step5PlaybackIdx + 1) % step5PlaybackPreloaded.length;
    }

    function step5StopPlayback() {
      if (step5PlaybackInterval) {
        clearInterval(step5PlaybackInterval);
        step5PlaybackInterval = null;
      }
      document.getElementById('step5PlayBtn').textContent = 'Play';
    }

    async function step5StartPlayback() {
      const seq = buildStep5PlaybackSequence();
      if (seq.length === 0) {
        document.getElementById('step5PlaybackInfo').textContent = 'Process frames and generate first.';
        return;
      }
      document.getElementById('step5PlaybackInfo').textContent = 'Preloading‚Ä¶';
      step5PlaybackPreloaded = [];
      for (const url of seq) {
        const img = new Image();
        await new Promise((resolve, reject) => {
          img.onload = resolve;
          img.onerror = reject;
          img.src = url;
        });
        step5PlaybackPreloaded.push(img);
      }
      const canvas = document.getElementById('step5PlaybackCanvas');
      const ph = document.getElementById('step5PlaybackPlaceholder');
      const imgEl = document.getElementById('step5PlaybackImg');
      ph.style.display = 'none';
      imgEl.style.display = 'none';
      canvas.style.display = 'block';
      canvas.width = step5PlaybackPreloaded[0].naturalWidth;
      canvas.height = step5PlaybackPreloaded[0].naturalHeight;
      step5PlaybackIdx = 0;
      const fps = Math.max(5, Math.min(60, parseInt(document.getElementById('step5PlaybackFps').value, 10) || 24));
      step5PlaybackInterval = setInterval(step5PlaybackTick, 1000 / fps);
      step5PlaybackTick();
      document.getElementById('step5PlayBtn').textContent = 'Stop';
    }

    let step6SourceAspect = 1;
    function getSpritesheetFrames() {
      const base = [...processedFrameCache];
      if (loopedFrameCache.length > 2) {
        for (let i = loopedFrameCache.length - 2; i >= 1; i--) base.push(loopedFrameCache[i]);
      }
      return base;
    }
    function updateStep6FrameDims() {
      const frames = getSpritesheetFrames();
      const size = parseInt(document.getElementById('step6FrameSize').value, 10) || 64;
      document.getElementById('step6FrameSizeVal').textContent = size;
      if (frames.length === 0) {
        document.getElementById('step6FrameDims').textContent = '‚Äî √ó ‚Äî';
        return;
      }
      const img = new Image();
      img.onload = () => {
        step6SourceAspect = img.naturalWidth / img.naturalHeight;
        const w = Math.round(size);
        const h = Math.round(size / step6SourceAspect);
        document.getElementById('step6FrameDims').textContent = `${w} √ó ${h}`;
      };
      img.onerror = () => { document.getElementById('step6FrameDims').textContent = '‚Äî √ó ‚Äî'; };
      img.src = frames[0];
    }

    function nextPowerOf2(n) {
      let p = 1;
      while (p < n) p *= 2;
      return p;
    }

    async function exportSpritesheet() {
      const frames = getSpritesheetFrames();
      const statusEl = document.getElementById('step6ExportStatus');
      if (frames.length === 0) {
        statusEl.textContent = 'No frames. Process frames or generate loop first.';
        return;
      }
      statusEl.textContent = 'Building‚Ä¶';
      const size = parseInt(document.getElementById('step6FrameSize').value, 10) || 64;
      const img = new Image();
      await new Promise((resolve, reject) => {
        img.onload = resolve;
        img.onerror = reject;
        img.src = frames[0];
      });
      const origW = img.naturalWidth, origH = img.naturalHeight;
      const aspect = origW / origH;
      const frameW = Math.round(size);
      const frameH = Math.round(size / aspect);
      const n = frames.length;
      const cols = Math.ceil(Math.sqrt(n));
      const rows = Math.ceil(n / cols);
      const contentW = cols * frameW;
      const contentH = rows * frameH;
      const sheetW = nextPowerOf2(contentW);
      const sheetH = nextPowerOf2(contentH);
      const canvas = document.createElement('canvas');
      canvas.width = sheetW;
      canvas.height = sheetH;
      const ctx = canvas.getContext('2d');
      ctx.clearRect(0, 0, sheetW, sheetH);
      for (let i = 0; i < frames.length; i++) {
        const col = i % cols, row = Math.floor(i / cols);
        const x = col * frameW, y = row * frameH;
        const fimg = new Image();
        await new Promise((resolve, reject) => {
          fimg.onload = resolve;
          fimg.onerror = reject;
          fimg.src = frames[i];
        });
        ctx.drawImage(fimg, 0, 0, origW, origH, x, y, frameW, frameH);
      }
      canvas.toBlob((blob) => {
        const a = document.createElement('a');
        a.href = URL.createObjectURL(blob);
        a.download = 'spritesheet.png';
        a.click();
        URL.revokeObjectURL(a.href);
        statusEl.textContent = `Saved ${sheetW}√ó${sheetH} PNG.`;
      }, 'image/png');
    }

    const chromaPickerZoomVal = document.getElementById('chromaPickerZoomVal');
    const chromaPreviewZoomVal = document.getElementById('chromaPreviewZoomVal');

    pickerViewport = initViewport(
      chromaPickerBox,
      document.getElementById('chromaPickerViewport'),
      chromaPickerCanvas,
      chromaPickerZoomVal,
      pickerViewportState,
      onChromaPick
    );
    previewViewport = initViewport(
      chromaPreviewBox,
      document.getElementById('chromaPreviewViewport'),
      chromaPreviewCanvas,
      chromaPreviewZoomVal,
      previewViewportState,
      null
    );

    document.getElementById('chromaPickerZoomIn').addEventListener('click', () => {
      const rect = chromaPickerBox.getBoundingClientRect();
      pickerViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('chromaPickerZoomOut').addEventListener('click', () => {
      const rect = chromaPickerBox.getBoundingClientRect();
      pickerViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.getElementById('chromaPreviewZoomIn').addEventListener('click', () => {
      const rect = chromaPreviewBox.getBoundingClientRect();
      previewViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('chromaPreviewZoomOut').addEventListener('click', () => {
      const rect = chromaPreviewBox.getBoundingClientRect();
      previewViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.querySelectorAll('input[name="resultPreviewBg"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        chromaPreviewBox.classList.remove('bg-black', 'bg-white', 'bg-gray');
        if (e.target.value !== 'transparent') {
          chromaPreviewBox.classList.add('bg-' + e.target.value);
        }
      });
    });
    chromaToleranceInput.addEventListener('input', () => {
      chromaToleranceVal.textContent = chromaToleranceInput.value;
      applyChromaPreview();
    });
    document.getElementById('holoRemoverEnabled').addEventListener('change', (e) => {
      document.getElementById('holoRemoverRow').style.display = e.target.checked ? 'flex' : 'none';
      applyChromaPreview();
    });
    document.getElementById('holoRemoverStrength').addEventListener('input', (e) => {
      document.getElementById('holoRemoverStrengthVal').textContent = e.target.value;
      applyChromaPreview();
    });
    document.getElementById('chromaMaxClusters').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      document.getElementById('chromaMaxClustersVal').textContent = v === 0 ? '‚àû' : v;
      applyChromaPreview();
    });
    document.getElementById('processAllFramesBtn').addEventListener('click', processAllFrames);
    document.getElementById('processedFramePrev').addEventListener('click', () => showProcessedFrame(processedFrameIdx - 1));
    document.getElementById('processedFrameNext').addEventListener('click', () => showProcessedFrame(processedFrameIdx + 1));
    document.getElementById('step4ZoomIn').addEventListener('click', () => {
      if (!step4Viewport) return;
      const rect = step4ViewportEl.getBoundingClientRect();
      step4Viewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('step4ZoomOut').addEventListener('click', () => {
      if (!step4Viewport) return;
      const rect = step4ViewportEl.getBoundingClientRect();
      step4Viewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.querySelectorAll('input[name="step4PreviewBg"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        step4ViewportEl.classList.remove('bg-black', 'bg-white', 'bg-gray');
        if (e.target.value !== 'transparent') step4ViewportEl.classList.add('bg-' + e.target.value);
      });
    });

    document.getElementById('step5GenerateEnabled').addEventListener('change', (e) => {
      document.getElementById('step5Content').classList.toggle('visible', e.target.checked);
      if (!e.target.checked) {
        loopedFrameCache.forEach(url => URL.revokeObjectURL(url));
        loopedFrameCache = [];
      }
    });
    document.getElementById('step5GenerateBtn').addEventListener('click', generateLoopFrames);
    document.getElementById('step5PlayBtn').addEventListener('click', () => {
      if (step5PlaybackInterval) step5StopPlayback();
      else step5StartPlayback();
    });
    document.getElementById('loopedFramePrev').addEventListener('click', () => showLoopedFrame(loopedFrameIdx - 1));
    document.getElementById('loopedFrameNext').addEventListener('click', () => showLoopedFrame(loopedFrameIdx + 1));
    document.getElementById('step5ZoomIn').addEventListener('click', () => {
      if (!step5Viewport) return;
      const rect = step5ViewportEl.getBoundingClientRect();
      step5Viewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('step5ZoomOut').addEventListener('click', () => {
      if (!step5Viewport) return;
      const rect = step5ViewportEl.getBoundingClientRect();
      step5Viewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.querySelectorAll('input[name="step5PreviewBg"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        step5ViewportEl.classList.remove('bg-black', 'bg-white', 'bg-gray');
        if (e.target.value !== 'transparent') step5ViewportEl.classList.add('bg-' + e.target.value);
      });
    });
    document.getElementById('step6FrameSize').addEventListener('input', updateStep6FrameDims);
    document.getElementById('step6ExportBtn').addEventListener('click', exportSpritesheet);

    firstFrameSlider.addEventListener('input', updateFirstFrame);
    lastFrameSlider.addEventListener('input', updateLastFrame);

    document.getElementById('samplingAll').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'none';
      document.getElementById('samplingTargetFpsRow').style.display = 'none';
      updateLoopedPreview();
    });
    document.getElementById('samplingEveryN').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'flex';
      document.getElementById('samplingTargetFpsRow').style.display = 'none';
      updateLoopedPreview();
    });
    document.getElementById('samplingTargetFps').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'none';
      document.getElementById('samplingTargetFpsRow').style.display = 'flex';
      updateLoopedPreview();
    });
    document.getElementById('samplingN').addEventListener('input', updateLoopedPreview);
    document.getElementById('samplingN').addEventListener('change', updateLoopedPreview);
    document.getElementById('samplingTargetFpsVal').addEventListener('input', updateLoopedPreview);
    document.getElementById('samplingTargetFpsVal').addEventListener('change', updateLoopedPreview);
    document.getElementById('loopedPreviewFps').addEventListener('input', (e) => {
      document.getElementById('loopedPreviewFpsVal').textContent = e.target.value;
      updateLoopedPreview();
    });

    uploadZone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        fileInput.click();
      }
    });
  </script>
</body>
</html>
