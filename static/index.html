<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Video to Sprite Sheet</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500&family=Outfit:wght@400;500;600&display=swap" rel="stylesheet">
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <style>
    :root {
      --bg: #0d1117;
      --surface: #161b22;
      --border: #30363d;
      --text: #e6edf3;
      --text-muted: #8b949e;
      --accent: #58a6ff;
      --accent-hover: #79b8ff;
      --success: #3fb950;
      --error: #f85149;
      --radius: 12px;
      --radius-sm: 8px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: 'Outfit', -apple-system, sans-serif;
      background: var(--bg);
      color: var(--text);
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2rem;
    }

    .container {
      width: 100%;
      max-width: 720px;
    }

    h1 {
      font-size: 1.75rem;
      font-weight: 600;
      margin-bottom: 0.5rem;
      letter-spacing: -0.02em;
    }

    .subtitle {
      color: var(--text-muted);
      font-size: 0.95rem;
      margin-bottom: 2rem;
    }

    .step-badge {
      display: inline-block;
      font-size: 0.7rem;
      font-weight: 500;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--accent);
      background: rgba(88, 166, 255, 0.15);
      padding: 0.25rem 0.6rem;
      border-radius: 6px;
      margin-bottom: 1rem;
    }

    .upload-zone {
      border: 2px dashed var(--border);
      border-radius: var(--radius);
      padding: 3rem 2rem;
      text-align: center;
      background: var(--surface);
      transition: border-color 0.2s, background 0.2s;
      cursor: pointer;
      position: relative;
      margin-bottom: 1.5rem;
    }

    .upload-zone:hover,
    .upload-zone.drag-over {
      border-color: var(--accent);
      background: rgba(88, 166, 255, 0.06);
    }

    .upload-zone input[type="file"] {
      position: absolute;
      inset: 0;
      opacity: 0;
      cursor: pointer;
      width: 100%;
      height: 100%;
    }

    .upload-zone .icon {
      font-size: 2.5rem;
      margin-bottom: 0.75rem;
      opacity: 0.7;
    }

    .upload-zone .hint {
      color: var(--text-muted);
      font-size: 0.85rem;
      font-family: 'JetBrains Mono', monospace;
    }

    .upload-zone .formats {
      color: var(--text-muted);
      font-size: 0.8rem;
      margin-top: 0.25rem;
    }

    .preview-section {
      display: none;
      background: var(--surface);
      border-radius: var(--radius);
      border: 1px solid var(--border);
      overflow: hidden;
    }

    .preview-section.visible {
      display: block;
    }

    .preview-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 1rem 1.25rem;
      border-bottom: 1px solid var(--border);
      gap: 1rem;
      flex-wrap: wrap;
    }

    .preview-header .filename {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text);
      word-break: break-all;
    }

    .preview-header .change-btn {
      font-size: 0.85rem;
      color: var(--accent);
      background: none;
      border: none;
      cursor: pointer;
      padding: 0.35rem 0.75rem;
      border-radius: var(--radius-sm);
      font-family: inherit;
      transition: background 0.2s, color 0.2s;
    }

    .preview-header .change-btn:hover {
      background: rgba(88, 166, 255, 0.15);
      color: var(--accent-hover);
    }

    .video-wrapper {
      background: #000;
      aspect-ratio: 16 / 9;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 240px;
    }

    .video-wrapper video {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
    }

    .status {
      padding: 1rem 1.25rem;
      font-size: 0.9rem;
      display: none;
    }

    .status.visible {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .status.loading {
      color: var(--text-muted);
    }

    .status.error {
      color: var(--error);
    }

    .status.success {
      color: var(--success);
    }

    .status .spinner {
      width: 18px;
      height: 18px;
      border: 2px solid var(--border);
      border-top-color: var(--accent);
      border-radius: 50%;
      animation: spin 0.8s linear infinite;
    }

    @keyframes spin {
      to { transform: rotate(360deg); }
    }

    .loading-zone {
      display: none;
      padding: 2rem;
      text-align: center;
    }

    .loading-zone.visible {
      display: block;
    }

    /* Step 2 â€” Frame range */
    .step2-section {
      display: none;
      margin-top: 2rem;
    }

    .step2-section.visible {
      display: block;
    }

    .frame-range-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-top: 1rem;
    }

    @media (max-width: 600px) {
      .frame-range-grid {
        grid-template-columns: 1fr;
      }
    }

    .frame-preview-card {
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
      overflow: hidden;
    }

    .frame-preview-card .label {
      padding: 0.75rem 1rem;
      border-bottom: 1px solid var(--border);
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-muted);
    }

    .frame-preview-card .preview-box {
      aspect-ratio: 16 / 9;
      background: #000;
      display: flex;
      align-items: center;
      justify-content: center;
      min-height: 120px;
    }

    .frame-preview-card .preview-box img {
      max-width: 100%;
      max-height: 100%;
      width: auto;
      height: auto;
      display: block;
    }

    .frame-preview-card .preview-box .placeholder {
      color: var(--text-muted);
      font-size: 0.85rem;
    }

    .overlay-card {
      grid-column: 1 / -1;
    }

    .overlay-box {
      position: relative;
    }

    .overlay-box img {
      position: absolute;
      inset: 0;
      width: 100%;
      height: 100%;
      object-fit: contain;
    }

    .overlay-box .overlay-bg {
      z-index: 0;
    }

    .overlay-box .overlay-fg {
      z-index: 1;
      opacity: 0.5;
    }

    .frame-preview-card .slider-row {
      padding: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }

    .frame-preview-card input[type="range"] {
      flex: 1;
      height: 6px;
      -webkit-appearance: none;
      appearance: none;
      background: var(--border);
      border-radius: 3px;
      outline: none;
    }

    .frame-preview-card input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      width: 18px;
      height: 18px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      transition: transform 0.15s;
    }

    .frame-preview-card input[type="range"]::-webkit-slider-thumb:hover {
      transform: scale(1.1);
    }

    .frame-preview-card input[type="range"]::-moz-range-thumb {
      width: 18px;
      height: 18px;
      background: var(--accent);
      border-radius: 50%;
      cursor: pointer;
      border: none;
    }

    .frame-preview-card .frame-num {
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
      color: var(--text);
      min-width: 4ch;
    }

    .range-summary {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(88, 166, 255, 0.08);
      border-radius: var(--radius-sm);
      font-size: 0.9rem;
      color: var(--text-muted);
    }

    .range-summary strong {
      color: var(--accent);
    }

    .sampling-section {
      margin-top: 1.5rem;
      padding: 1rem 1.25rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .sampling-section .label {
      font-size: 0.85rem;
      font-weight: 500;
      color: var(--text-muted);
      margin-bottom: 0.75rem;
      display: block;
    }

    .sampling-options {
      display: flex;
      flex-wrap: wrap;
      gap: 1rem;
      align-items: center;
    }

    .sampling-option {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      cursor: pointer;
    }

    .sampling-option input[type="radio"] {
      accent-color: var(--accent);
    }

    .sampling-n-input {
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .sampling-n-input input {
      width: 4rem;
      padding: 0.35rem 0.5rem;
      background: var(--bg);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      font-family: 'JetBrains Mono', monospace;
      font-size: 0.9rem;
    }

    .looped-preview-card {
      margin-top: 1.5rem;
    }

    .looped-preview-controls {
      display: flex;
      flex-wrap: wrap;
      align-items: center;
      gap: 1rem;
      padding: 1rem;
      border-top: 1px solid var(--border);
    }

    .looped-preview-controls label {
      font-size: 0.85rem;
      color: var(--text-muted);
    }

    .looped-preview-controls input[type="range"] {
      width: 120px;
    }

    .looped-preview-controls .fps-value {
      font-family: 'JetBrains Mono', monospace;
      min-width: 3ch;
    }

    .looped-preview-info {
      font-size: 0.8rem;
      color: var(--text-muted);
    }

    /* Step 3 â€” Chroma key */
    .step3-section {
      display: none;
      margin-top: 2rem;
    }

    .step3-section.visible {
      display: block;
    }

    .chroma-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 1.5rem;
      margin-top: 1rem;
    }

    @media (max-width: 700px) {
      .chroma-grid { grid-template-columns: 1fr; }
    }

    .chroma-viewport {
      position: relative;
      background: #000;
      aspect-ratio: 16 / 9;
      min-height: 140px;
      overflow: hidden;
      cursor: grab;
      user-select: none;
      -webkit-user-select: none;
    }

    .chroma-viewport.dragging {
      cursor: grabbing;
    }

    .chroma-picker-box.dragging {
      cursor: grabbing;
    }

    .chroma-viewport-inner {
      position: absolute;
      transform-origin: 0 0;
      will-change: transform;
    }

    .chroma-viewport-inner canvas {
      display: block;
      vertical-align: top;
    }

    .chroma-viewport.chroma-preview-box {
      background: repeating-conic-gradient(#333 0% 25%, #222 0% 50%) 50% / 16px 16px;
    }

    .chroma-viewport.chroma-preview-box.bg-black {
      background: #000;
    }

    .chroma-viewport.chroma-preview-box.bg-white {
      background: #fff;
    }

    .chroma-viewport.chroma-preview-box.bg-gray {
      background: #666;
    }

    .chroma-preview-bg-options {
      display: flex;
      align-items: center;
      gap: 0.75rem;
      flex-wrap: wrap;
      margin-top: 0.5rem;
    }

    .chroma-preview-bg-options label {
      display: flex;
      align-items: center;
      gap: 0.35rem;
      font-size: 0.85rem;
      color: var(--text-muted);
      cursor: pointer;
    }

    .chroma-preview-bg-options input[type="radio"] {
      accent-color: var(--accent);
    }

    .chroma-zoom-controls {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      margin-top: 0.5rem;
    }

    .chroma-zoom-controls button {
      padding: 0.25rem 0.6rem;
      font-size: 0.85rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius-sm);
      color: var(--text);
      cursor: pointer;
    }

    .chroma-zoom-controls button:hover {
      background: rgba(88, 166, 255, 0.15);
      border-color: var(--accent);
    }

    .chroma-controls {
      margin-top: 1rem;
      padding: 1rem;
      background: var(--surface);
      border: 1px solid var(--border);
      border-radius: var(--radius);
    }

    .chroma-controls .row {
      display: flex;
      align-items: center;
      gap: 1rem;
      flex-wrap: wrap;
      margin-bottom: 0.75rem;
    }

    .chroma-controls .row:last-child { margin-bottom: 0; }

    .color-swatch {
      width: 36px;
      height: 36px;
      border-radius: 6px;
      border: 2px solid var(--border);
      flex-shrink: 0;
    }

    .color-swatch.empty {
      background: var(--border);
    }
  </style>
</head>
<body>
  <div class="container">
    <span class="step-badge">Step 1 â€” Upload</span>
    <h1>Video to Sprite Sheet</h1>
    <p class="subtitle">Upload a video file to get started. Supports MP4, AVI, MOV, WebM.</p>

    <div class="upload-zone" id="uploadZone" role="button" tabindex="0">
      <input type="file" id="fileInput" accept="video/mp4,video/quicktime,video/x-msvideo,video/webm,.mp4,.avi,.mov,.webm">
      <div class="icon">ðŸŽ¬</div>
      <div class="hint">Drop a video file here or click to browse</div>
      <div class="formats">MP4, AVI, MOV, WebM</div>
    </div>

    <div class="loading-zone" id="loadingZone">
      <div class="status loading visible" id="statusLoading">
        <span class="spinner"></span>
        <span>Uploadingâ€¦</span>
      </div>
    </div>

    <div class="preview-section" id="previewSection">
      <div class="preview-header">
        <span class="filename" id="filenameDisplay">â€”</span>
        <button type="button" class="change-btn" id="changeBtn">Change video</button>
      </div>
      <div class="video-wrapper">
        <video id="videoPreview" controls playsinline preload="metadata"></video>
      </div>
      <div class="status error" id="statusError"></div>
    </div>

    <div class="step2-section" id="step2Section">
      <span class="step-badge">Step 2 â€” Frame range</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Select frame range</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Use sliders to set the first and last frame of your sequence.</p>
      <div class="frame-range-grid">
        <div class="frame-preview-card">
          <div class="label">First frame</div>
          <div class="preview-box" id="firstFrameBox">
            <span class="placeholder">â€”</span>
          </div>
          <div class="slider-row">
            <input type="range" id="firstFrameSlider" min="0" max="0" value="0">
            <span class="frame-num" id="firstFrameNum">0</span>
          </div>
        </div>
        <div class="frame-preview-card">
          <div class="label">Last frame</div>
          <div class="preview-box" id="lastFrameBox">
            <span class="placeholder">â€”</span>
          </div>
          <div class="slider-row">
            <input type="range" id="lastFrameSlider" min="0" max="0" value="0">
            <span class="frame-num" id="lastFrameNum">0</span>
          </div>
        </div>
      </div>
      <div class="frame-preview-card overlay-card">
        <div class="label">Compare: first over last</div>
        <div class="preview-box overlay-box" id="overlayBox">
          <img class="overlay-bg" id="overlayBg" alt="">
          <img class="overlay-fg" id="overlayFg" alt="">
          <span class="placeholder" id="overlayPlaceholder">â€”</span>
        </div>
      </div>
      <div class="range-summary" id="rangeSummary">
        Range: frame <strong id="rangeStart">0</strong> to <strong id="rangeEnd">0</strong> â€” <strong id="rangeCount">0</strong> frames
      </div>

      <div class="sampling-section">
        <span class="label">Frame sampling</span>
        <div class="sampling-options">
          <label class="sampling-option">
            <input type="radio" name="sampling" value="all" id="samplingAll" checked>
            All frames
          </label>
          <label class="sampling-option">
            <input type="radio" name="sampling" value="everyN" id="samplingEveryN">
            Every Nth frame
          </label>
          <div class="sampling-n-input" id="samplingNRow" style="display:none">
            <span class="looped-preview-info">N =</span>
            <input type="number" id="samplingN" min="2" max="100" value="2">
          </div>
          <label class="sampling-option">
            <input type="radio" name="sampling" value="targetFps" id="samplingTargetFps">
            Target FPS
          </label>
          <div class="sampling-n-input" id="samplingTargetFpsRow" style="display:none">
            <span class="looped-preview-info">FPS</span>
            <input type="number" id="samplingTargetFpsVal" min="5" max="60" value="12" placeholder="12">
          </div>
        </div>
      </div>

      <div class="frame-preview-card looped-preview-card">
        <div class="label">Looped preview</div>
        <div class="preview-box" id="loopedPreviewBox">
          <img id="loopedPreviewImg" alt="" style="max-width:100%;max-height:100%;width:auto;height:auto;display:block;">
          <span class="placeholder" id="loopedPreviewPlaceholder">â€”</span>
        </div>
        <div class="looped-preview-controls">
          <label>Playback FPS:</label>
          <input type="range" id="loopedPreviewFps" min="5" max="60" value="24">
          <span class="fps-value" id="loopedPreviewFpsVal">24</span>
          <span class="looped-preview-info" id="loopedPreviewInfo">â€” frames</span>
        </div>
      </div>
    </div>

    <div class="step3-section" id="step3Section">
      <span class="step-badge">Step 3 â€” Chroma key</span>
      <h2 style="font-size:1.25rem; margin-bottom:0.5rem;">Pick color & remove background</h2>
      <p class="subtitle" style="margin-bottom:1rem;">Click on the first frame to pick the background color. Adjust tolerance to fine-tune removal.</p>
      <div class="chroma-grid">
        <div class="frame-preview-card">
          <div class="label">Click to pick color Â· Wheel zoom Â· Drag to pan</div>
          <div class="chroma-viewport chroma-picker-box" id="chromaPickerBox">
            <div class="chroma-viewport-inner" id="chromaPickerViewport">
              <canvas id="chromaPickerCanvas"></canvas>
            </div>
          </div>
          <div class="chroma-zoom-controls">
            <button type="button" id="chromaPickerZoomOut">âˆ’</button>
            <span class="fps-value" id="chromaPickerZoomVal">100%</span>
            <button type="button" id="chromaPickerZoomIn">+</button>
          </div>
        </div>
        <div class="frame-preview-card">
          <div class="label">Result preview Â· Wheel zoom Â· Drag to pan</div>
          <div class="chroma-viewport chroma-preview-box" id="chromaPreviewBox">
            <div class="chroma-viewport-inner" id="chromaPreviewViewport">
              <canvas id="chromaPreviewCanvas"></canvas>
            </div>
          </div>
          <div class="chroma-zoom-controls">
            <button type="button" id="chromaPreviewZoomOut">âˆ’</button>
            <span class="fps-value" id="chromaPreviewZoomVal">100%</span>
            <button type="button" id="chromaPreviewZoomIn">+</button>
          </div>
          <div class="chroma-preview-bg-options">
            <label><input type="radio" name="resultPreviewBg" value="transparent" checked> Transparent</label>
            <label><input type="radio" name="resultPreviewBg" value="black"> Black</label>
            <label><input type="radio" name="resultPreviewBg" value="white"> White</label>
            <label><input type="radio" name="resultPreviewBg" value="gray"> Gray</label>
          </div>
        </div>
      </div>
      <div class="chroma-controls">
        <div class="row">
          <div class="color-swatch empty" id="pickedColorSwatch"></div>
          <div>
            <span class="looped-preview-info">Picked color:</span>
            <span id="pickedColorText" style="font-family:'JetBrains Mono',monospace; font-size:0.9rem;">â€”</span>
          </div>
        </div>
        <div class="row">
          <label class="looped-preview-info">Tolerance:</label>
          <input type="range" id="chromaTolerance" min="0" max="100" value="30">
          <span class="fps-value" id="chromaToleranceVal">30</span>
        </div>
        <div class="row" style="margin-top:1rem; padding-top:1rem; border-top:1px solid var(--border)">
          <label class="sampling-option">
            <input type="checkbox" id="holoRemoverEnabled">
            Holo Remover
          </label>
          <span class="looped-preview-info">Removes color spill (outline) from the removed background</span>
        </div>
        <div class="row" id="holoRemoverRow" style="display:none;align-items:center">
          <label class="looped-preview-info">Strength:</label>
          <input type="range" id="holoRemoverStrength" min="0" max="100" value="80">
          <span class="fps-value" id="holoRemoverStrengthVal">80</span>
        </div>
        <div class="row" style="margin-top:1rem; padding-top:1rem; border-top:1px solid var(--border)">
          <label class="looped-preview-info">Max clusters:</label>
          <input type="range" id="chromaMaxClusters" min="0" max="100" value="0">
          <span class="fps-value" id="chromaMaxClustersVal">âˆž</span>
          <span class="looped-preview-info">0 = keep all, 100 = keep top 100</span>
        </div>
      </div>
    </div>
  </div>

  <script>
    const uploadZone = document.getElementById('uploadZone');
    const fileInput = document.getElementById('fileInput');
    const loadingZone = document.getElementById('loadingZone');
    const statusLoading = document.getElementById('statusLoading');
    const previewSection = document.getElementById('previewSection');
    const filenameDisplay = document.getElementById('filenameDisplay');
    const videoPreview = document.getElementById('videoPreview');
    const changeBtn = document.getElementById('changeBtn');
    const statusError = document.getElementById('statusError');

    function showUpload() {
      uploadZone.style.display = 'block';
      loadingZone.classList.remove('visible');
      previewSection.classList.remove('visible');
      statusError.classList.remove('visible');
    }

    function showLoading() {
      uploadZone.style.display = 'none';
      loadingZone.classList.add('visible');
      statusLoading.classList.add('visible');
      previewSection.classList.remove('visible');
    }

    function showPreview(filename, url, videoId) {
      loadingZone.classList.remove('visible');
      previewSection.classList.add('visible');
      filenameDisplay.textContent = filename;
      videoPreview.src = url;
      statusError.classList.remove('visible');
      uploadZone.style.display = 'block';
      initStep2(videoId);
    }

    function showError(msg) {
      loadingZone.classList.remove('visible');
      statusLoading.classList.remove('visible');
      uploadZone.style.display = 'block';
      statusError.textContent = msg;
      statusError.classList.add('visible');
    }

    async function uploadFile(file) {
      if (!file || !file.type.startsWith('video/')) {
        showError('Please select a valid video file.');
        return;
      }

      showLoading();
      const formData = new FormData();
      formData.append('file', file);

      try {
        const res = await fetch('/api/upload', {
          method: 'POST',
          body: formData,
        });

        const data = await res.json().catch(() => ({}));

        if (!res.ok) {
          showError(data.detail || `Upload failed (${res.status})`);
          return;
        }

        const base = window.location.origin;
        const videoUrl = data.url.startsWith('http') ? data.url : base + data.url;
        showPreview(data.filename, videoUrl, data.id);
      } catch (err) {
        showError('Network error. Is the server running?');
        console.error(err);
      }
    }

    function onFileSelected(e) {
      const file = e.target?.files?.[0] || e.dataTransfer?.files?.[0];
      if (file) uploadFile(file);
      fileInput.value = '';
      uploadZone.classList.remove('drag-over');
    }

    uploadZone.addEventListener('click', (e) => {
      if (e.target !== fileInput) fileInput.click();
    });

    uploadZone.addEventListener('dragover', (e) => {
      e.preventDefault();
      uploadZone.classList.add('drag-over');
    });

    uploadZone.addEventListener('dragleave', () => {
      uploadZone.classList.remove('drag-over');
    });

    uploadZone.addEventListener('drop', (e) => {
      e.preventDefault();
      onFileSelected({ target: null, dataTransfer: e.dataTransfer });
    });

    fileInput.addEventListener('change', onFileSelected);

    changeBtn.addEventListener('click', () => {
      if (loopedPreviewInterval) {
        clearInterval(loopedPreviewInterval);
        loopedPreviewInterval = null;
      }
      videoPreview.pause();
      videoPreview.src = '';
      frameCache.forEach(url => URL.revokeObjectURL(url));
      frameCache = [];
      step2Section.classList.remove('visible');
      step3Section.classList.remove('visible');
      showUpload();
      fileInput.click();
    });

    // Step 2 â€” Frame range (all frames cached, instant preview on slider move)
    const step2Section = document.getElementById('step2Section');
    const firstFrameSlider = document.getElementById('firstFrameSlider');
    const lastFrameSlider = document.getElementById('lastFrameSlider');
    const firstFrameNum = document.getElementById('firstFrameNum');
    const lastFrameNum = document.getElementById('lastFrameNum');
    const firstFrameBox = document.getElementById('firstFrameBox');
    const lastFrameBox = document.getElementById('lastFrameBox');
    const rangeStart = document.getElementById('rangeStart');
    const rangeEnd = document.getElementById('rangeEnd');
    const rangeCount = document.getElementById('rangeCount');
    const overlayBg = document.getElementById('overlayBg');
    const overlayFg = document.getElementById('overlayFg');
    const overlayPlaceholder = document.getElementById('overlayPlaceholder');

    const step3Section = document.getElementById('step3Section');
    const chromaPickerCanvas = document.getElementById('chromaPickerCanvas');
    const chromaPreviewCanvas = document.getElementById('chromaPreviewCanvas');
    const chromaPickerBox = document.getElementById('chromaPickerBox');
    const pickedColorSwatch = document.getElementById('pickedColorSwatch');
    const pickedColorText = document.getElementById('pickedColorText');
    const chromaToleranceInput = document.getElementById('chromaTolerance');
    const chromaToleranceVal = document.getElementById('chromaToleranceVal');

    let videoId = null;
    let frameCache = []; // blob URLs for each frame
    let videoFps = 30; // original video FPS from metadata
    let loopedPreviewInterval = null;
    let chromaPickedColor = null; // { r, g, b }
    let chromaSourceImg = null;   // loaded Image for first frame

    function setPreviewFromCache(boxEl, index) {
      if (index < 0 || index >= frameCache.length) return;
      const placeholder = boxEl.querySelector('.placeholder');
      let img = boxEl.querySelector('img');
      if (placeholder) placeholder.style.display = 'none';
      if (!img) {
        img = document.createElement('img');
        img.alt = 'Frame ' + index;
        boxEl.appendChild(img);
      }
      img.src = frameCache[index];
    }

    function updateFirstFrame() {
      const idx = parseInt(firstFrameSlider.value, 10);
      firstFrameNum.textContent = idx;
      setPreviewFromCache(firstFrameBox, idx);
      const lastVal = parseInt(lastFrameSlider.value, 10);
      if (idx > lastVal) {
        lastFrameSlider.value = idx;
        lastFrameNum.textContent = idx;
        setPreviewFromCache(lastFrameBox, idx);
      }
      updateRangeSummary();
      updateOverlay();
      updateLoopedPreview();
      updateChromaPicker();
    }

    function updateLastFrame() {
      const idx = parseInt(lastFrameSlider.value, 10);
      lastFrameNum.textContent = idx;
      setPreviewFromCache(lastFrameBox, idx);
      const firstVal = parseInt(firstFrameSlider.value, 10);
      if (idx < firstVal) {
        firstFrameSlider.value = idx;
        firstFrameNum.textContent = idx;
        setPreviewFromCache(firstFrameBox, idx);
      }
      updateRangeSummary();
      updateOverlay();
      updateLoopedPreview();
    }

    function updateRangeSummary() {
      const first = parseInt(firstFrameSlider.value, 10);
      const last = parseInt(lastFrameSlider.value, 10);
      const count = Math.max(0, last - first + 1);
      rangeStart.textContent = first;
      rangeEnd.textContent = last;
      rangeCount.textContent = count;
    }

    function updateOverlay() {
      if (frameCache.length === 0) return;
      const firstIdx = parseInt(firstFrameSlider.value, 10);
      const lastIdx = parseInt(lastFrameSlider.value, 10);
      if (firstIdx < 0 || firstIdx >= frameCache.length || lastIdx < 0 || lastIdx >= frameCache.length) return;
      overlayPlaceholder.style.display = 'none';
      overlayBg.src = frameCache[lastIdx];
      overlayFg.src = frameCache[firstIdx];
    }

    function getSampledIndices() {
      const first = parseInt(firstFrameSlider.value, 10);
      const last = parseInt(lastFrameSlider.value, 10);
      const indices = [];
      if (first > last) return indices;
      const rangeCount = last - first + 1;
      const useEveryN = document.getElementById('samplingEveryN').checked;
      const useTargetFps = document.getElementById('samplingTargetFps').checked;
      if (useTargetFps) {
        const targetFps = Math.max(5, Math.min(60, parseInt(document.getElementById('samplingTargetFpsVal').value, 10) || 12));
        const targetCount = Math.max(1, Math.round(rangeCount * targetFps / videoFps));
        for (let i = 0; i < targetCount; i++) {
          const idx = first + Math.round(i * (last - first) / Math.max(1, targetCount - 1));
          indices.push(Math.min(idx, last));
        }
      } else if (useEveryN) {
        const n = Math.max(2, parseInt(document.getElementById('samplingN').value, 10) || 2);
        for (let i = first; i <= last; i += n) indices.push(i);
      } else {
        for (let i = first; i <= last; i++) indices.push(i);
      }
      return indices;
    }

    function startLoopedPreview() {
      if (loopedPreviewInterval) clearInterval(loopedPreviewInterval);
      const indices = getSampledIndices();
      const loopedImg = document.getElementById('loopedPreviewImg');
      const loopedPlaceholder = document.getElementById('loopedPreviewPlaceholder');
      const loopedInfo = document.getElementById('loopedPreviewInfo');
      if (indices.length === 0 || frameCache.length === 0) {
        loopedPlaceholder.textContent = 'â€”';
        loopedPlaceholder.style.display = 'inline';
        loopedImg.style.display = 'none';
        loopedInfo.textContent = '0 frames';
        return;
      }
      loopedPlaceholder.style.display = 'none';
      loopedImg.style.display = 'block';
      loopedImg.src = frameCache[indices[0]];
      loopedInfo.textContent = indices.length + ' frames';
      const fps = parseInt(document.getElementById('loopedPreviewFps').value, 10) || 24;
      const msPerFrame = 1000 / Math.max(1, fps);
      let idx = 0;
      loopedPreviewInterval = setInterval(() => {
        idx = (idx + 1) % indices.length;
        loopedImg.src = frameCache[indices[idx]];
      }, msPerFrame);
    }

    function updateLoopedPreview() {
      startLoopedPreview();
    }

    async function initStep2(id) {
      videoId = id;
      step2Section.classList.add('visible');
      const summaryEl = step2Section.querySelector('.range-summary');
      firstFrameBox.innerHTML = '<span class="placeholder">Loading framesâ€¦</span>';
      lastFrameBox.innerHTML = '<span class="placeholder">Loading framesâ€¦</span>';
      try {
        const metaRes = await fetch(`/api/video/${id}/metadata`);
        if (!metaRes.ok) throw new Error('Failed to load metadata');
        const meta = await metaRes.json();
        const totalFrames = Math.max(1, meta.frame_count || 1);
        const maxIdx = totalFrames - 1;

        summaryEl.textContent = `Loading ${totalFrames} framesâ€¦`;
        const zipRes = await fetch(`/api/video/${id}/frames`);
        if (!zipRes.ok) throw new Error('Failed to load frames');
        const zipBlob = await zipRes.blob();
        const zip = await JSZip.loadAsync(zipBlob);
        const names = Object.keys(zip.files).filter(n => n.endsWith('.png')).sort();
        frameCache = [];
        for (const name of names) {
          const blob = await zip.files[name].async('blob');
          frameCache.push(URL.createObjectURL(blob));
        }
        const loadedCount = frameCache.length;
        const safeMaxIdx = Math.min(maxIdx, loadedCount - 1);

        firstFrameSlider.min = 0;
        firstFrameSlider.max = safeMaxIdx;
        firstFrameSlider.value = 0;
        lastFrameSlider.min = 0;
        lastFrameSlider.max = safeMaxIdx;
        lastFrameSlider.value = safeMaxIdx;
        firstFrameNum.textContent = '0';
        lastFrameNum.textContent = String(safeMaxIdx);
        updateRangeSummary();

        firstFrameBox.innerHTML = '';
        lastFrameBox.innerHTML = '';
        setPreviewFromCache(firstFrameBox, 0);
        setPreviewFromCache(lastFrameBox, safeMaxIdx);
        overlayPlaceholder.style.display = 'none';
        overlayBg.src = frameCache[safeMaxIdx];
        overlayFg.src = frameCache[0];
        videoFps = meta.fps || 30;
        document.getElementById('samplingNRow').style.display = document.getElementById('samplingEveryN').checked ? 'flex' : 'none';
        document.getElementById('samplingTargetFpsRow').style.display = document.getElementById('samplingTargetFps').checked ? 'flex' : 'none';
        document.getElementById('loopedPreviewFpsVal').textContent = document.getElementById('loopedPreviewFps').value;
        startLoopedPreview();
        initStep3();
      } catch (e) {
        summaryEl.innerHTML = 'Could not load frames: ' + (e.message || 'Unknown error');
        firstFrameBox.innerHTML = '<span class="placeholder">Error</span>';
        lastFrameBox.innerHTML = '<span class="placeholder">Error</span>';
      }
    }

    const ZOOM_MIN = 25;
    const ZOOM_MAX = 500;

    function initViewport(viewportEl, innerEl, canvas, zoomValEl, state, onPickClick) {
      function applyTransform() {
        const s = state.scale / 100;
        innerEl.style.transform = `translate(${state.offsetX}px,${state.offsetY}px) scale(${s})`;
        zoomValEl.textContent = Math.round(state.scale) + '%';
      }

      function screenToContent(sx, sy) {
        const rect = viewportEl.getBoundingClientRect();
        const s = state.scale / 100;
        return {
          x: (sx - rect.left - state.offsetX) / s,
          y: (sy - rect.top - state.offsetY) / s
        };
      }

      function centerContent() {
        const rect = viewportEl.getBoundingClientRect();
        const s = state.scale / 100;
        const cw = canvas.width, ch = canvas.height;
        state.offsetX = (rect.width - cw * s) / 2;
        state.offsetY = (rect.height - ch * s) / 2;
        applyTransform();
      }

      function zoomAt(centerX, centerY, delta) {
        const rect = viewportEl.getBoundingClientRect();
        const mx = centerX - rect.left;
        const my = centerY - rect.top;
        const oldScale = state.scale / 100;
        const newScale = Math.max(ZOOM_MIN / 100, Math.min(ZOOM_MAX / 100, oldScale * delta));
        state.scale = newScale * 100;
        state.offsetX = mx - (mx - state.offsetX) / oldScale * newScale;
        state.offsetY = my - (my - state.offsetY) / oldScale * newScale;
        applyTransform();
      }

      let dragStart = null;

      viewportEl.addEventListener('wheel', (e) => {
        e.preventDefault();
        const delta = e.deltaY > 0 ? 0.9 : 1.1;
        zoomAt(e.clientX, e.clientY, delta);
      }, { passive: false });

      viewportEl.addEventListener('mousedown', (e) => {
        if (e.button !== 0) return;
        e.preventDefault();
        dragStart = { x: e.clientX, y: e.clientY, ox: state.offsetX, oy: state.offsetY };
        viewportEl.classList.add('dragging');
      });
      viewportEl.addEventListener('contextmenu', (e) => e.preventDefault());

      viewportEl.addEventListener('mousemove', (e) => {
        if (dragStart) {
          state.offsetX = dragStart.ox + (e.clientX - dragStart.x);
          state.offsetY = dragStart.oy + (e.clientY - dragStart.y);
          applyTransform();
        }
      });

      const onMouseUp = (e) => {
        if (e.button !== 0) return;
        if (dragStart && onPickClick) {
          const dx = e.clientX - dragStart.x, dy = e.clientY - dragStart.y;
          if (dx * dx + dy * dy < 16) {
            const p = screenToContent(dragStart.x, dragStart.y);
            onPickClick(Math.floor(p.x), Math.floor(p.y));
          }
        }
        dragStart = null;
        viewportEl.classList.remove('dragging');
      };

      viewportEl.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mouseup', onMouseUp);
      document.addEventListener('mousemove', (e) => {
        if (dragStart) {
          state.offsetX = dragStart.ox + (e.clientX - dragStart.x);
          state.offsetY = dragStart.oy + (e.clientY - dragStart.y);
          applyTransform();
        }
      });

      applyTransform();
      return { applyTransform, centerContent, zoomAt, screenToContent, state };
    }

    const pickerViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    const previewViewportState = { scale: 100, offsetX: 0, offsetY: 0 };
    let pickerViewport, previewViewport;

    function loadChromaFrame() {
      const indices = getSampledIndices();
      if (indices.length === 0 || frameCache.length === 0) return;
      const firstIdx = indices[0];
      const img = new Image();
      img.onload = () => {
        chromaSourceImg = img;
        const w = img.naturalWidth;
        const h = img.naturalHeight;
        chromaPickerCanvas.width = w;
        chromaPickerCanvas.height = h;
        chromaPreviewCanvas.width = w;
        chromaPreviewCanvas.height = h;
        const ctx = chromaPickerCanvas.getContext('2d', { willReadFrequently: true });
        ctx.drawImage(img, 0, 0);
        chromaPickedColor = null;
        pickedColorSwatch.classList.add('empty');
        pickedColorSwatch.style.backgroundColor = '';
        pickedColorText.textContent = 'â€” click to pick';
        applyChromaPreview();
        pickerViewportState.scale = 100;
        pickerViewportState.offsetX = 0;
        pickerViewportState.offsetY = 0;
        previewViewportState.scale = 100;
        previewViewportState.offsetX = 0;
        previewViewportState.offsetY = 0;
        if (pickerViewport) pickerViewport.centerContent();
        if (previewViewport) previewViewport.centerContent();
      };
      img.src = frameCache[firstIdx];
    }

    function rgbToHex(r, g, b) {
      return '#' + [r, g, b].map(x => x.toString(16).padStart(2, '0')).join('');
    }

    function applyClusterFilter(data, width, height, maxClusters) {
      if (maxClusters <= 0) return;
      const len = width * height;
      const clusterId = new Int32Array(len);
      clusterId.fill(-1);
      for (let i = 0; i < len; i++) {
        if (data[i * 4 + 3] > 0) clusterId[i] = 0;
      }
      const clusters = [];
      let nextId = 1;
      const stack = [];
      const dx = [-1, 0, 1, -1, 1, -1, 0, 1];
      const dy = [-1, -1, -1, 0, 0, 1, 1, 1];
      for (let y = 0; y < height; y++) {
        for (let x = 0; x < width; x++) {
          const idx = y * width + x;
          if (clusterId[idx] !== 0) continue;
          let size = 0;
          stack.length = 0;
          stack.push([x, y]);
          clusterId[idx] = nextId;
          size++;
          while (stack.length > 0) {
            const [cx, cy] = stack.pop();
            for (let d = 0; d < 8; d++) {
              const nx = cx + dx[d], ny = cy + dy[d];
              if (nx < 0 || nx >= width || ny < 0 || ny >= height) continue;
              const nidx = ny * width + nx;
              if (clusterId[nidx] === 0) {
                clusterId[nidx] = nextId;
                size++;
                stack.push([nx, ny]);
              }
            }
          }
          clusters.push({ id: nextId, size });
          nextId++;
        }
      }
      clusters.sort((a, b) => b.size - a.size);
      const keepIds = new Set(clusters.slice(0, maxClusters).map(c => c.id));
      for (let i = 0; i < len; i++) {
        const cid = clusterId[i];
        if (cid > 0 && !keepIds.has(cid)) data[i * 4 + 3] = 0;
      }
    }

    function applyDespill(data, keyR, keyG, keyB, strength) {
      const s = strength / 100;
      for (let i = 0; i < data.length; i += 4) {
        if (data[i + 3] === 0) continue;
        let r = data[i], g = data[i + 1], b = data[i + 2];
        let spill = 0;
        if (keyG >= keyR && keyG >= keyB) {
          spill = Math.max(0, g - Math.max(r, b));
          g = Math.round(g - spill * s);
        } else if (keyB >= keyR && keyB >= keyG) {
          spill = Math.max(0, b - Math.max(r, g));
          b = Math.round(b - spill * s);
        } else if (keyR >= keyG && keyR >= keyB) {
          spill = Math.max(0, r - Math.max(g, b));
          r = Math.round(r - spill * s);
        }
        data[i] = Math.max(0, Math.min(255, r));
        data[i + 1] = Math.max(0, Math.min(255, g));
        data[i + 2] = Math.max(0, Math.min(255, b));
      }
    }

    function applyChromaPreview() {
      if (!chromaSourceImg) return;
      const ctx = chromaPreviewCanvas.getContext('2d', { willReadFrequently: true });
      ctx.drawImage(chromaSourceImg, 0, 0);
      if (chromaPickedColor === null) return;
      const imgData = ctx.getImageData(0, 0, chromaPreviewCanvas.width, chromaPreviewCanvas.height);
      const data = imgData.data;
      const kr = chromaPickedColor.r, kg = chromaPickedColor.g, kb = chromaPickedColor.b;
      const tol = parseInt(chromaToleranceInput.value, 10) || 30;
      const threshold = (tol / 100) * 442;
      for (let i = 0; i < data.length; i += 4) {
        const dr = data[i] - kr, dg = data[i + 1] - kg, db = data[i + 2] - kb;
        const dist = Math.sqrt(dr * dr + dg * dg + db * db);
        if (dist <= threshold) data[i + 3] = 0;
      }
      const holoEnabled = document.getElementById('holoRemoverEnabled').checked;
      if (holoEnabled) {
        const holoStrength = parseInt(document.getElementById('holoRemoverStrength').value, 10) || 80;
        applyDespill(data, kr, kg, kb, holoStrength);
      }
      const maxClusters = parseInt(document.getElementById('chromaMaxClusters').value, 10) || 0;
      if (maxClusters > 0) {
        applyClusterFilter(data, chromaPreviewCanvas.width, chromaPreviewCanvas.height, maxClusters);
      }
      ctx.putImageData(imgData, 0, 0);
    }

    function onChromaPick(x, y) {
      if (!chromaSourceImg || frameCache.length === 0) return;
      const w = chromaPickerCanvas.width, h = chromaPickerCanvas.height;
      if (x < 0 || x >= w || y < 0 || y >= h) return;
      const ctx = chromaPickerCanvas.getContext('2d', { willReadFrequently: true });
      const pixel = ctx.getImageData(x, y, 1, 1).data;
      chromaPickedColor = { r: pixel[0], g: pixel[1], b: pixel[2] };
      pickedColorSwatch.classList.remove('empty');
      pickedColorSwatch.style.backgroundColor = rgbToHex(pixel[0], pixel[1], pixel[2]);
      pickedColorText.textContent = rgbToHex(pixel[0], pixel[1], pixel[2]) + ' rgb(' + pixel[0] + ',' + pixel[1] + ',' + pixel[2] + ')';
      applyChromaPreview();
    }

    function updateChromaPicker() {
      if (!step3Section.classList.contains('visible')) return;
      loadChromaFrame();
    }

    function initStep3() {
      step3Section.classList.add('visible');
      chromaToleranceVal.textContent = chromaToleranceInput.value;
      document.getElementById('chromaMaxClustersVal').textContent = 
        parseInt(document.getElementById('chromaMaxClusters').value, 10) === 0 ? 'âˆž' : document.getElementById('chromaMaxClusters').value;
      loadChromaFrame();
    }

    const chromaPickerZoomVal = document.getElementById('chromaPickerZoomVal');
    const chromaPreviewZoomVal = document.getElementById('chromaPreviewZoomVal');

    pickerViewport = initViewport(
      chromaPickerBox,
      document.getElementById('chromaPickerViewport'),
      chromaPickerCanvas,
      chromaPickerZoomVal,
      pickerViewportState,
      onChromaPick
    );
    previewViewport = initViewport(
      chromaPreviewBox,
      document.getElementById('chromaPreviewViewport'),
      chromaPreviewCanvas,
      chromaPreviewZoomVal,
      previewViewportState,
      null
    );

    document.getElementById('chromaPickerZoomIn').addEventListener('click', () => {
      const rect = chromaPickerBox.getBoundingClientRect();
      pickerViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('chromaPickerZoomOut').addEventListener('click', () => {
      const rect = chromaPickerBox.getBoundingClientRect();
      pickerViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.getElementById('chromaPreviewZoomIn').addEventListener('click', () => {
      const rect = chromaPreviewBox.getBoundingClientRect();
      previewViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 1.25);
    });
    document.getElementById('chromaPreviewZoomOut').addEventListener('click', () => {
      const rect = chromaPreviewBox.getBoundingClientRect();
      previewViewport.zoomAt(rect.left + rect.width / 2, rect.top + rect.height / 2, 0.8);
    });
    document.querySelectorAll('input[name="resultPreviewBg"]').forEach(radio => {
      radio.addEventListener('change', (e) => {
        chromaPreviewBox.classList.remove('bg-black', 'bg-white', 'bg-gray');
        if (e.target.value !== 'transparent') {
          chromaPreviewBox.classList.add('bg-' + e.target.value);
        }
      });
    });
    chromaToleranceInput.addEventListener('input', () => {
      chromaToleranceVal.textContent = chromaToleranceInput.value;
      applyChromaPreview();
    });
    document.getElementById('holoRemoverEnabled').addEventListener('change', (e) => {
      document.getElementById('holoRemoverRow').style.display = e.target.checked ? 'flex' : 'none';
      applyChromaPreview();
    });
    document.getElementById('holoRemoverStrength').addEventListener('input', (e) => {
      document.getElementById('holoRemoverStrengthVal').textContent = e.target.value;
      applyChromaPreview();
    });
    document.getElementById('chromaMaxClusters').addEventListener('input', (e) => {
      const v = parseInt(e.target.value, 10);
      document.getElementById('chromaMaxClustersVal').textContent = v === 0 ? 'âˆž' : v;
      applyChromaPreview();
    });

    firstFrameSlider.addEventListener('input', updateFirstFrame);
    lastFrameSlider.addEventListener('input', updateLastFrame);

    document.getElementById('samplingAll').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'none';
      document.getElementById('samplingTargetFpsRow').style.display = 'none';
      updateLoopedPreview();
    });
    document.getElementById('samplingEveryN').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'flex';
      document.getElementById('samplingTargetFpsRow').style.display = 'none';
      updateLoopedPreview();
    });
    document.getElementById('samplingTargetFps').addEventListener('change', () => {
      document.getElementById('samplingNRow').style.display = 'none';
      document.getElementById('samplingTargetFpsRow').style.display = 'flex';
      updateLoopedPreview();
    });
    document.getElementById('samplingN').addEventListener('input', updateLoopedPreview);
    document.getElementById('samplingN').addEventListener('change', updateLoopedPreview);
    document.getElementById('samplingTargetFpsVal').addEventListener('input', updateLoopedPreview);
    document.getElementById('samplingTargetFpsVal').addEventListener('change', updateLoopedPreview);
    document.getElementById('loopedPreviewFps').addEventListener('input', (e) => {
      document.getElementById('loopedPreviewFpsVal').textContent = e.target.value;
      updateLoopedPreview();
    });

    uploadZone.addEventListener('keydown', (e) => {
      if (e.key === 'Enter' || e.key === ' ') {
        e.preventDefault();
        fileInput.click();
      }
    });
  </script>
</body>
</html>
